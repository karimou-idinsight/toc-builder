"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/layout",{

/***/ "(app-pages-browser)/./src/app/store/boardSlice.js":
/*!*************************************!*\
  !*** ./src/app/store/boardSlice.js ***!
  \*************************************/
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addEdge: function() { return /* binding */ addEdge; },\n/* harmony export */   addList: function() { return /* binding */ addList; },\n/* harmony export */   addNode: function() { return /* binding */ addNode; },\n/* harmony export */   clearCausalPath: function() { return /* binding */ clearCausalPath; },\n/* harmony export */   deleteEdge: function() { return /* binding */ deleteEdge; },\n/* harmony export */   deleteList: function() { return /* binding */ deleteList; },\n/* harmony export */   deleteNode: function() { return /* binding */ deleteNode; },\n/* harmony export */   initializeBoard: function() { return /* binding */ initializeBoard; },\n/* harmony export */   moveNode: function() { return /* binding */ moveNode; },\n/* harmony export */   reorderLists: function() { return /* binding */ reorderLists; },\n/* harmony export */   reorderNodes: function() { return /* binding */ reorderNodes; },\n/* harmony export */   setActiveId: function() { return /* binding */ setActiveId; },\n/* harmony export */   setCausalPathFocalNode: function() { return /* binding */ setCausalPathFocalNode; },\n/* harmony export */   setCausalPathMode: function() { return /* binding */ setCausalPathMode; },\n/* harmony export */   setCausalPathNodes: function() { return /* binding */ setCausalPathNodes; },\n/* harmony export */   setDragType: function() { return /* binding */ setDragType; },\n/* harmony export */   setDraggableNodes: function() { return /* binding */ setDraggableNodes; },\n/* harmony export */   setLinkMode: function() { return /* binding */ setLinkMode; },\n/* harmony export */   setLinkSource: function() { return /* binding */ setLinkSource; },\n/* harmony export */   toggleNodeDraggable: function() { return /* binding */ toggleNodeDraggable; },\n/* harmony export */   updateBoard: function() { return /* binding */ updateBoard; },\n/* harmony export */   updateEdge: function() { return /* binding */ updateEdge; },\n/* harmony export */   updateList: function() { return /* binding */ updateList; },\n/* harmony export */   updateNode: function() { return /* binding */ updateNode; }\n/* harmony export */ });\n/* harmony import */ var _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @reduxjs/toolkit */ \"(app-pages-browser)/./node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs\");\n/* harmony import */ var _utils_tocModels__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/tocModels */ \"(app-pages-browser)/./src/app/utils/tocModels.js\");\n\n\nconst initialState = {\n    board: null,\n    linkMode: false,\n    linkSource: null,\n    activeId: null,\n    dragType: null,\n    draggableNodes: [],\n    causalPathMode: false,\n    causalPathNodes: [],\n    causalPathFocalNode: null\n};\nconst boardSlice = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.createSlice)({\n    name: \"board\",\n    initialState,\n    reducers: {\n        // Initialize board\n        initializeBoard: (state, action)=>{\n            state.board = action.payload || (0,_utils_tocModels__WEBPACK_IMPORTED_MODULE_0__.createBoard)();\n        },\n        // Board operations\n        updateBoard: (state, action)=>{\n            if (state.board) {\n                state.board = {\n                    ...state.board,\n                    ...action.payload,\n                    updatedAt: new Date().toISOString()\n                };\n            }\n        },\n        // List operations\n        addList: (state, action)=>{\n            if (state.board) {\n                state.board.lists.push(action.payload);\n                state.board.updatedAt = new Date().toISOString();\n            }\n        },\n        updateList: (state, action)=>{\n            if (state.board) {\n                const { listId, updates } = action.payload;\n                const listIndex = state.board.lists.findIndex((list)=>list.id === listId);\n                if (listIndex !== -1) {\n                    state.board.lists[listIndex] = {\n                        ...state.board.lists[listIndex],\n                        ...updates\n                    };\n                    state.board.updatedAt = new Date().toISOString();\n                }\n            }\n        },\n        deleteList: (state, action)=>{\n            if (state.board) {\n                const listId = action.payload;\n                state.board.lists = state.board.lists.filter((list)=>list.id !== listId);\n                state.board.nodes = state.board.nodes.filter((node)=>node.listId !== listId);\n                state.board.updatedAt = new Date().toISOString();\n            }\n        },\n        reorderLists: (state, action)=>{\n            if (state.board) {\n                const { draggedId, targetId } = action.payload;\n                const lists = [\n                    ...state.board.lists\n                ];\n                const draggedIndex = lists.findIndex((list)=>list.id === draggedId);\n                const targetIndex = lists.findIndex((list)=>list.id === targetId);\n                if (draggedIndex !== -1 && targetIndex !== -1) {\n                    const [draggedList] = lists.splice(draggedIndex, 1);\n                    lists.splice(targetIndex, 0, draggedList);\n                    lists.forEach((list, index)=>{\n                        list.order = index;\n                    });\n                    state.board.lists = lists;\n                    state.board.updatedAt = new Date().toISOString();\n                }\n            }\n        },\n        // Node operations\n        addNode: (state, action)=>{\n            if (state.board) {\n                state.board.nodes.push(action.payload);\n                state.board.updatedAt = new Date().toISOString();\n            }\n        },\n        updateNode: (state, action)=>{\n            if (state.board) {\n                const { nodeId, updates } = action.payload;\n                const nodeIndex = state.board.nodes.findIndex((node)=>node.id === nodeId);\n                if (nodeIndex !== -1) {\n                    state.board.nodes[nodeIndex] = {\n                        ...state.board.nodes[nodeIndex],\n                        ...updates,\n                        updatedAt: new Date().toISOString()\n                    };\n                    state.board.updatedAt = new Date().toISOString();\n                }\n            }\n        },\n        deleteNode: (state, action)=>{\n            if (state.board) {\n                const nodeId = action.payload;\n                state.board.nodes = state.board.nodes.filter((node)=>node.id !== nodeId);\n                state.board.edges = state.board.edges.filter((edge)=>edge.sourceId !== nodeId && edge.targetId !== nodeId);\n                state.board.updatedAt = new Date().toISOString();\n            }\n        },\n        reorderNodes: (state, action)=>{\n            if (state.board) {\n                const { listId, draggedId, targetId } = action.payload;\n                const listNodes = state.board.nodes.filter((node)=>node.listId === listId);\n                const draggedIndex = listNodes.findIndex((node)=>node.id === draggedId);\n                const targetIndex = listNodes.findIndex((node)=>node.id === targetId);\n                if (draggedIndex !== -1 && targetIndex !== -1) {\n                    const [draggedNode] = listNodes.splice(draggedIndex, 1);\n                    listNodes.splice(targetIndex, 0, draggedNode);\n                    listNodes.forEach((node, index)=>{\n                        const nodeIndex = state.board.nodes.findIndex((n)=>n.id === node.id);\n                        if (nodeIndex !== -1) {\n                            state.board.nodes[nodeIndex].order = index;\n                        }\n                    });\n                    state.board.updatedAt = new Date().toISOString();\n                }\n            }\n        },\n        moveNode: (state, action)=>{\n            if (state.board) {\n                const { nodeId, targetListId } = action.payload;\n                const nodeIndex = state.board.nodes.findIndex((node)=>node.id === nodeId);\n                if (nodeIndex !== -1) {\n                    state.board.nodes[nodeIndex].listId = targetListId;\n                    const targetListNodes = state.board.nodes.filter((node)=>node.listId === targetListId);\n                    targetListNodes.forEach((node, index)=>{\n                        const nIndex = state.board.nodes.findIndex((n)=>n.id === node.id);\n                        if (nIndex !== -1) {\n                            state.board.nodes[nIndex].order = index;\n                        }\n                    });\n                    state.board.updatedAt = new Date().toISOString();\n                }\n            }\n        },\n        // Edge operations\n        addEdge: (state, action)=>{\n            if (state.board) {\n                state.board.edges.push(action.payload);\n                state.board.updatedAt = new Date().toISOString();\n            }\n        },\n        updateEdge: (state, action)=>{\n            if (state.board) {\n                const { edgeId, updates } = action.payload;\n                const edgeIndex = state.board.edges.findIndex((edge)=>edge.id === edgeId);\n                if (edgeIndex !== -1) {\n                    state.board.edges[edgeIndex] = {\n                        ...state.board.edges[edgeIndex],\n                        ...updates\n                    };\n                    state.board.updatedAt = new Date().toISOString();\n                }\n            }\n        },\n        deleteEdge: (state, action)=>{\n            if (state.board) {\n                const edgeId = action.payload;\n                state.board.edges = state.board.edges.filter((edge)=>edge.id !== edgeId);\n                state.board.updatedAt = new Date().toISOString();\n            }\n        },\n        // UI state\n        setLinkMode: (state, action)=>{\n            state.linkMode = action.payload;\n        },\n        setLinkSource: (state, action)=>{\n            state.linkSource = action.payload;\n        },\n        setActiveId: (state, action)=>{\n            state.activeId = action.payload;\n        },\n        setDragType: (state, action)=>{\n            state.dragType = action.payload;\n        },\n        setDraggableNodes: (state, action)=>{\n            state.draggableNodes = action.payload;\n        },\n        toggleNodeDraggable: (state, action)=>{\n            const { nodeId, isDraggable } = action.payload;\n            if (isDraggable) {\n                if (!state.draggableNodes.includes(nodeId)) {\n                    state.draggableNodes.push(nodeId);\n                }\n            } else {\n                state.draggableNodes = state.draggableNodes.filter((id)=>id !== nodeId);\n            }\n        },\n        setCausalPathMode: (state, action)=>{\n            state.causalPathMode = action.payload;\n        },\n        setCausalPathNodes: (state, action)=>{\n            state.causalPathNodes = action.payload;\n        },\n        setCausalPathFocalNode: (state, action)=>{\n            state.causalPathFocalNode = action.payload;\n        },\n        clearCausalPath: (state)=>{\n            state.causalPathNodes = [];\n            state.causalPathFocalNode = null;\n            state.causalPathMode = false;\n        }\n    }\n});\nconst { initializeBoard, updateBoard, addList, updateList, deleteList, reorderLists, addNode, updateNode, deleteNode, reorderNodes, moveNode, addEdge, updateEdge, deleteEdge, setLinkMode, setLinkSource, setActiveId, setDragType, setDraggableNodes, toggleNodeDraggable, setCausalPathMode, setCausalPathNodes, setCausalPathFocalNode, clearCausalPath } = boardSlice.actions;\n/* harmony default export */ __webpack_exports__[\"default\"] = (boardSlice.reducer);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = __webpack_module__.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = __webpack_module__.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, __webpack_module__.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                __webpack_module__.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                __webpack_module__.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        __webpack_module__.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    __webpack_module__.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvc3RvcmUvYm9hcmRTbGljZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUErQztBQUNFO0FBRWpELE1BQU1FLGVBQWU7SUFDbkJDLE9BQU87SUFDUEMsVUFBVTtJQUNWQyxZQUFZO0lBQ1pDLFVBQVU7SUFDVkMsVUFBVTtJQUNWQyxnQkFBZ0IsRUFBRTtJQUNsQkMsZ0JBQWdCO0lBQ2hCQyxpQkFBaUIsRUFBRTtJQUNuQkMscUJBQXFCO0FBQ3ZCO0FBRUEsTUFBTUMsYUFBYVosNkRBQVdBLENBQUM7SUFDN0JhLE1BQU07SUFDTlg7SUFDQVksVUFBVTtRQUNSLG1CQUFtQjtRQUNuQkMsaUJBQWlCLENBQUNDLE9BQU9DO1lBQ3ZCRCxNQUFNYixLQUFLLEdBQUdjLE9BQU9DLE9BQU8sSUFBSWpCLDZEQUFXQTtRQUM3QztRQUVBLG1CQUFtQjtRQUNuQmtCLGFBQWEsQ0FBQ0gsT0FBT0M7WUFDbkIsSUFBSUQsTUFBTWIsS0FBSyxFQUFFO2dCQUNmYSxNQUFNYixLQUFLLEdBQUc7b0JBQ1osR0FBR2EsTUFBTWIsS0FBSztvQkFDZCxHQUFHYyxPQUFPQyxPQUFPO29CQUNqQkUsV0FBVyxJQUFJQyxPQUFPQyxXQUFXO2dCQUNuQztZQUNGO1FBQ0Y7UUFFQSxrQkFBa0I7UUFDbEJDLFNBQVMsQ0FBQ1AsT0FBT0M7WUFDZixJQUFJRCxNQUFNYixLQUFLLEVBQUU7Z0JBQ2ZhLE1BQU1iLEtBQUssQ0FBQ3FCLEtBQUssQ0FBQ0MsSUFBSSxDQUFDUixPQUFPQyxPQUFPO2dCQUNyQ0YsTUFBTWIsS0FBSyxDQUFDaUIsU0FBUyxHQUFHLElBQUlDLE9BQU9DLFdBQVc7WUFDaEQ7UUFDRjtRQUVBSSxZQUFZLENBQUNWLE9BQU9DO1lBQ2xCLElBQUlELE1BQU1iLEtBQUssRUFBRTtnQkFDZixNQUFNLEVBQUV3QixNQUFNLEVBQUVDLE9BQU8sRUFBRSxHQUFHWCxPQUFPQyxPQUFPO2dCQUMxQyxN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QUFlLEdBQUdPLE9BQU9DLE9BQU87UUFDeEM7UUFFQTRELHdCQUF3QixDQUFDOUQsT0FBT0M7WUFDOUJELE1BQU1MLG1CQUFtQixHQUFHTSxPQUFPQyxPQUFPO1FBQzVDO1FBRUE2RCxpQkFBaUIsQ0FBQy9EO1lBQ2hCQSxNQUFNTixlQUFlLEdBQUcsRUFBRTtZQUMxQk0sTUFBTUwsbUJBQW1CLEdBQUc7WUFDNUJLLE1BQU1QLGNBQWMsR0FBRztRQUN6QjtJQUNGO0FBQ0Y7QUFFTyxNQUFNLEVBQ1hNLGVBQWUsRUFDZkksV0FBVyxFQUNYSSxPQUFPLEVBQ1BHLFVBQVUsRUFDVk8sVUFBVSxFQUNWSSxZQUFZLEVBQ1pVLE9BQU8sRUFDUEMsVUFBVSxFQUNWRyxVQUFVLEVBQ1ZJLFlBQVksRUFDWkksUUFBUSxFQUNSSSxPQUFPLEVBQ1BDLFVBQVUsRUFDVkcsVUFBVSxFQUNWQyxXQUFXLEVBQ1hDLGFBQWEsRUFDYkMsV0FBVyxFQUNYQyxXQUFXLEVBQ1hDLGlCQUFpQixFQUNqQkMsbUJBQW1CLEVBQ25CRyxpQkFBaUIsRUFDakJDLGtCQUFrQixFQUNsQkMsc0JBQXNCLEVBQ3RCQyxlQUFlLEVBQ2hCLEdBQUduRSxXQUFXb0UsT0FBTyxDQUFDO0FBRXZCLCtEQUFlcEUsV0FBV3FFLE9BQU8sRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvYXBwL3N0b3JlL2JvYXJkU2xpY2UuanM/OWI4NiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVTbGljZSB9IGZyb20gJ0ByZWR1eGpzL3Rvb2xraXQnO1xuaW1wb3J0IHsgY3JlYXRlQm9hcmQgfSBmcm9tICcuLi91dGlscy90b2NNb2RlbHMnO1xuXG5jb25zdCBpbml0aWFsU3RhdGUgPSB7XG4gIGJvYXJkOiBudWxsLFxuICBsaW5rTW9kZTogZmFsc2UsXG4gIGxpbmtTb3VyY2U6IG51bGwsXG4gIGFjdGl2ZUlkOiBudWxsLFxuICBkcmFnVHlwZTogbnVsbCxcbiAgZHJhZ2dhYmxlTm9kZXM6IFtdLFxuICBjYXVzYWxQYXRoTW9kZTogZmFsc2UsXG4gIGNhdXNhbFBhdGhOb2RlczogW10sXG4gIGNhdXNhbFBhdGhGb2NhbE5vZGU6IG51bGwsXG59O1xuXG5jb25zdCBib2FyZFNsaWNlID0gY3JlYXRlU2xpY2Uoe1xuICBuYW1lOiAnYm9hcmQnLFxuICBpbml0aWFsU3RhdGUsXG4gIHJlZHVjZXJzOiB7XG4gICAgLy8gSW5pdGlhbGl6ZSBib2FyZFxuICAgIGluaXRpYWxpemVCb2FyZDogKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgICAgIHN0YXRlLmJvYXJkID0gYWN0aW9uLnBheWxvYWQgfHwgY3JlYXRlQm9hcmQoKTtcbiAgICB9LFxuXG4gICAgLy8gQm9hcmQgb3BlcmF0aW9uc1xuICAgIHVwZGF0ZUJvYXJkOiAoc3RhdGUsIGFjdGlvbikgPT4ge1xuICAgICAgaWYgKHN0YXRlLmJvYXJkKSB7XG4gICAgICAgIHN0YXRlLmJvYXJkID0ge1xuICAgICAgICAgIC4uLnN0YXRlLmJvYXJkLFxuICAgICAgICAgIC4uLmFjdGlvbi5wYXlsb2FkLFxuICAgICAgICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vIExpc3Qgb3BlcmF0aW9uc1xuICAgIGFkZExpc3Q6IChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gICAgICBpZiAoc3RhdGUuYm9hcmQpIHtcbiAgICAgICAgc3RhdGUuYm9hcmQubGlzdHMucHVzaChhY3Rpb24ucGF5bG9hZCk7XG4gICAgICAgIHN0YXRlLmJvYXJkLnVwZGF0ZWRBdCA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgdXBkYXRlTGlzdDogKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgICAgIGlmIChzdGF0ZS5ib2FyZCkge1xuICAgICAgICBjb25zdCB7IGxpc3RJZCwgdXBkYXRlcyB9ID0gYWN0aW9uLnBheWxvYWQ7XG4gICAgICAgIGNvbnN0IGxpc3RJbmRleCA9IHN0YXRlLmJvYXJkLmxpc3RzLmZpbmRJbmRleChsaXN0ID0+IGxpc3QuaWQgPT09IGxpc3RJZCk7XG4gICAgICAgIGlmIChsaXN0SW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgc3RhdGUuYm9hcmQubGlzdHNbbGlzdEluZGV4XSA9IHtcbiAgICAgICAgICAgIC4uLnN0YXRlLmJvYXJkLmxpc3RzW2xpc3RJbmRleF0sXG4gICAgICAgICAgICAuLi51cGRhdGVzXG4gICAgICAgICAgfTtcbiAgICAgICAgICBzdGF0ZS5ib2FyZC51cGRhdGVkQXQgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZGVsZXRlTGlzdDogKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgICAgIGlmIChzdGF0ZS5ib2FyZCkge1xuICAgICAgICBjb25zdCBsaXN0SWQgPSBhY3Rpb24ucGF5bG9hZDtcbiAgICAgICAgc3RhdGUuYm9hcmQubGlzdHMgPSBzdGF0ZS5ib2FyZC5saXN0cy5maWx0ZXIobGlzdCA9PiBsaXN0LmlkICE9PSBsaXN0SWQpO1xuICAgICAgICBzdGF0ZS5ib2FyZC5ub2RlcyA9IHN0YXRlLmJvYXJkLm5vZGVzLmZpbHRlcihub2RlID0+IG5vZGUubGlzdElkICE9PSBsaXN0SWQpO1xuICAgICAgICBzdGF0ZS5ib2FyZC51cGRhdGVkQXQgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHJlb3JkZXJMaXN0czogKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgICAgIGlmIChzdGF0ZS5ib2FyZCkge1xuICAgICAgICBjb25zdCB7IGRyYWdnZWRJZCwgdGFyZ2V0SWQgfSA9IGFjdGlvbi5wYXlsb2FkO1xuICAgICAgICBjb25zdCBsaXN0cyA9IFsuLi5zdGF0ZS5ib2FyZC5saXN0c107XG4gICAgICAgIGNvbnN0IGRyYWdnZWRJbmRleCA9IGxpc3RzLmZpbmRJbmRleChsaXN0ID0+IGxpc3QuaWQgPT09IGRyYWdnZWRJZCk7XG4gICAgICAgIGNvbnN0IHRhcmdldEluZGV4ID0gbGlzdHMuZmluZEluZGV4KGxpc3QgPT4gbGlzdC5pZCA9PT0gdGFyZ2V0SWQpO1xuICAgICAgICBcbiAgICAgICAgaWYgKGRyYWdnZWRJbmRleCAhPT0gLTEgJiYgdGFyZ2V0SW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgY29uc3QgW2RyYWdnZWRMaXN0XSA9IGxpc3RzLnNwbGljZShkcmFnZ2VkSW5kZXgsIDEpO1xuICAgICAgICAgIGxpc3RzLnNwbGljZSh0YXJnZXRJbmRleCwgMCwgZHJhZ2dlZExpc3QpO1xuICAgICAgICAgIFxuICAgICAgICAgIGxpc3RzLmZvckVhY2goKGxpc3QsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBsaXN0Lm9yZGVyID0gaW5kZXg7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgXG4gICAgICAgICAgc3RhdGUuYm9hcmQubGlzdHMgPSBsaXN0cztcbiAgICAgICAgICBzdGF0ZS5ib2FyZC51cGRhdGVkQXQgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gTm9kZSBvcGVyYXRpb25zXG4gICAgYWRkTm9kZTogKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgICAgIGlmIChzdGF0ZS5ib2FyZCkge1xuICAgICAgICBzdGF0ZS5ib2FyZC5ub2Rlcy5wdXNoKGFjdGlvbi5wYXlsb2FkKTtcbiAgICAgICAgc3RhdGUuYm9hcmQudXBkYXRlZEF0ID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICB1cGRhdGVOb2RlOiAoc3RhdGUsIGFjdGlvbikgPT4ge1xuICAgICAgaWYgKHN0YXRlLmJvYXJkKSB7XG4gICAgICAgIGNvbnN0IHsgbm9kZUlkLCB1cGRhdGVzIH0gPSBhY3Rpb24ucGF5bG9hZDtcbiAgICAgICAgY29uc3Qgbm9kZUluZGV4ID0gc3RhdGUuYm9hcmQubm9kZXMuZmluZEluZGV4KG5vZGUgPT4gbm9kZS5pZCA9PT0gbm9kZUlkKTtcbiAgICAgICAgaWYgKG5vZGVJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICBzdGF0ZS5ib2FyZC5ub2Rlc1tub2RlSW5kZXhdID0ge1xuICAgICAgICAgICAgLi4uc3RhdGUuYm9hcmQubm9kZXNbbm9kZUluZGV4XSxcbiAgICAgICAgICAgIC4uLnVwZGF0ZXMsXG4gICAgICAgICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgICAgIH07XG4gICAgICAgICAgc3RhdGUuYm9hcmQudXBkYXRlZEF0ID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGRlbGV0ZU5vZGU6IChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gICAgICBpZiAoc3RhdGUuYm9hcmQpIHtcbiAgICAgICAgY29uc3Qgbm9kZUlkID0gYWN0aW9uLnBheWxvYWQ7XG4gICAgICAgIHN0YXRlLmJvYXJkLm5vZGVzID0gc3RhdGUuYm9hcmQubm9kZXMuZmlsdGVyKG5vZGUgPT4gbm9kZS5pZCAhPT0gbm9kZUlkKTtcbiAgICAgICAgc3RhdGUuYm9hcmQuZWRnZXMgPSBzdGF0ZS5ib2FyZC5lZGdlcy5maWx0ZXIoXG4gICAgICAgICAgZWRnZSA9PiBlZGdlLnNvdXJjZUlkICE9PSBub2RlSWQgJiYgZWRnZS50YXJnZXRJZCAhPT0gbm9kZUlkXG4gICAgICAgICk7XG4gICAgICAgIHN0YXRlLmJvYXJkLnVwZGF0ZWRBdCA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVvcmRlck5vZGVzOiAoc3RhdGUsIGFjdGlvbikgPT4ge1xuICAgICAgaWYgKHN0YXRlLmJvYXJkKSB7XG4gICAgICAgIGNvbnN0IHsgbGlzdElkLCBkcmFnZ2VkSWQsIHRhcmdldElkIH0gPSBhY3Rpb24ucGF5bG9hZDtcbiAgICAgICAgY29uc3QgbGlzdE5vZGVzID0gc3RhdGUuYm9hcmQubm9kZXMuZmlsdGVyKG5vZGUgPT4gbm9kZS5saXN0SWQgPT09IGxpc3RJZCk7XG4gICAgICAgIGNvbnN0IGRyYWdnZWRJbmRleCA9IGxpc3ROb2Rlcy5maW5kSW5kZXgobm9kZSA9PiBub2RlLmlkID09PSBkcmFnZ2VkSWQpO1xuICAgICAgICBjb25zdCB0YXJnZXRJbmRleCA9IGxpc3ROb2Rlcy5maW5kSW5kZXgobm9kZSA9PiBub2RlLmlkID09PSB0YXJnZXRJZCk7XG4gICAgICAgIFxuICAgICAgICBpZiAoZHJhZ2dlZEluZGV4ICE9PSAtMSAmJiB0YXJnZXRJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICBjb25zdCBbZHJhZ2dlZE5vZGVdID0gbGlzdE5vZGVzLnNwbGljZShkcmFnZ2VkSW5kZXgsIDEpO1xuICAgICAgICAgIGxpc3ROb2Rlcy5zcGxpY2UodGFyZ2V0SW5kZXgsIDAsIGRyYWdnZWROb2RlKTtcbiAgICAgICAgICBcbiAgICAgICAgICBsaXN0Tm9kZXMuZm9yRWFjaCgobm9kZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGVJbmRleCA9IHN0YXRlLmJvYXJkLm5vZGVzLmZpbmRJbmRleChuID0+IG4uaWQgPT09IG5vZGUuaWQpO1xuICAgICAgICAgICAgaWYgKG5vZGVJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgc3RhdGUuYm9hcmQubm9kZXNbbm9kZUluZGV4XS5vcmRlciA9IGluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIFxuICAgICAgICAgIHN0YXRlLmJvYXJkLnVwZGF0ZWRBdCA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBtb3ZlTm9kZTogKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgICAgIGlmIChzdGF0ZS5ib2FyZCkge1xuICAgICAgICBjb25zdCB7IG5vZGVJZCwgdGFyZ2V0TGlzdElkIH0gPSBhY3Rpb24ucGF5bG9hZDtcbiAgICAgICAgY29uc3Qgbm9kZUluZGV4ID0gc3RhdGUuYm9hcmQubm9kZXMuZmluZEluZGV4KG5vZGUgPT4gbm9kZS5pZCA9PT0gbm9kZUlkKTtcbiAgICAgICAgXG4gICAgICAgIGlmIChub2RlSW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgc3RhdGUuYm9hcmQubm9kZXNbbm9kZUluZGV4XS5saXN0SWQgPSB0YXJnZXRMaXN0SWQ7XG4gICAgICAgICAgXG4gICAgICAgICAgY29uc3QgdGFyZ2V0TGlzdE5vZGVzID0gc3RhdGUuYm9hcmQubm9kZXMuZmlsdGVyKG5vZGUgPT4gbm9kZS5saXN0SWQgPT09IHRhcmdldExpc3RJZCk7XG4gICAgICAgICAgdGFyZ2V0TGlzdE5vZGVzLmZvckVhY2goKG5vZGUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuSW5kZXggPSBzdGF0ZS5ib2FyZC5ub2Rlcy5maW5kSW5kZXgobiA9PiBuLmlkID09PSBub2RlLmlkKTtcbiAgICAgICAgICAgIGlmIChuSW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgIHN0YXRlLmJvYXJkLm5vZGVzW25JbmRleF0ub3JkZXIgPSBpbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBcbiAgICAgICAgICBzdGF0ZS5ib2FyZC51cGRhdGVkQXQgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gRWRnZSBvcGVyYXRpb25zXG4gICAgYWRkRWRnZTogKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgICAgIGlmIChzdGF0ZS5ib2FyZCkge1xuICAgICAgICBzdGF0ZS5ib2FyZC5lZGdlcy5wdXNoKGFjdGlvbi5wYXlsb2FkKTtcbiAgICAgICAgc3RhdGUuYm9hcmQudXBkYXRlZEF0ID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICB1cGRhdGVFZGdlOiAoc3RhdGUsIGFjdGlvbikgPT4ge1xuICAgICAgaWYgKHN0YXRlLmJvYXJkKSB7XG4gICAgICAgIGNvbnN0IHsgZWRnZUlkLCB1cGRhdGVzIH0gPSBhY3Rpb24ucGF5bG9hZDtcbiAgICAgICAgY29uc3QgZWRnZUluZGV4ID0gc3RhdGUuYm9hcmQuZWRnZXMuZmluZEluZGV4KGVkZ2UgPT4gZWRnZS5pZCA9PT0gZWRnZUlkKTtcbiAgICAgICAgaWYgKGVkZ2VJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICBzdGF0ZS5ib2FyZC5lZGdlc1tlZGdlSW5kZXhdID0ge1xuICAgICAgICAgICAgLi4uc3RhdGUuYm9hcmQuZWRnZXNbZWRnZUluZGV4XSxcbiAgICAgICAgICAgIC4uLnVwZGF0ZXNcbiAgICAgICAgICB9O1xuICAgICAgICAgIHN0YXRlLmJvYXJkLnVwZGF0ZWRBdCA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBkZWxldGVFZGdlOiAoc3RhdGUsIGFjdGlvbikgPT4ge1xuICAgICAgaWYgKHN0YXRlLmJvYXJkKSB7XG4gICAgICAgIGNvbnN0IGVkZ2VJZCA9IGFjdGlvbi5wYXlsb2FkO1xuICAgICAgICBzdGF0ZS5ib2FyZC5lZGdlcyA9IHN0YXRlLmJvYXJkLmVkZ2VzLmZpbHRlcihlZGdlID0+IGVkZ2UuaWQgIT09IGVkZ2VJZCk7XG4gICAgICAgIHN0YXRlLmJvYXJkLnVwZGF0ZWRBdCA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gVUkgc3RhdGVcbiAgICBzZXRMaW5rTW9kZTogKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgICAgIHN0YXRlLmxpbmtNb2RlID0gYWN0aW9uLnBheWxvYWQ7XG4gICAgfSxcblxuICAgIHNldExpbmtTb3VyY2U6IChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gICAgICBzdGF0ZS5saW5rU291cmNlID0gYWN0aW9uLnBheWxvYWQ7XG4gICAgfSxcblxuICAgIHNldEFjdGl2ZUlkOiAoc3RhdGUsIGFjdGlvbikgPT4ge1xuICAgICAgc3RhdGUuYWN0aXZlSWQgPSBhY3Rpb24ucGF5bG9hZDtcbiAgICB9LFxuXG4gICAgc2V0RHJhZ1R5cGU6IChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gICAgICBzdGF0ZS5kcmFnVHlwZSA9IGFjdGlvbi5wYXlsb2FkO1xuICAgIH0sXG5cbiAgICBzZXREcmFnZ2FibGVOb2RlczogKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgICAgIHN0YXRlLmRyYWdnYWJsZU5vZGVzID0gYWN0aW9uLnBheWxvYWQ7XG4gICAgfSxcblxuICAgIHRvZ2dsZU5vZGVEcmFnZ2FibGU6IChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gICAgICBjb25zdCB7IG5vZGVJZCwgaXNEcmFnZ2FibGUgfSA9IGFjdGlvbi5wYXlsb2FkO1xuICAgICAgaWYgKGlzRHJhZ2dhYmxlKSB7XG4gICAgICAgIGlmICghc3RhdGUuZHJhZ2dhYmxlTm9kZXMuaW5jbHVkZXMobm9kZUlkKSkge1xuICAgICAgICAgIHN0YXRlLmRyYWdnYWJsZU5vZGVzLnB1c2gobm9kZUlkKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUuZHJhZ2dhYmxlTm9kZXMgPSBzdGF0ZS5kcmFnZ2FibGVOb2Rlcy5maWx0ZXIoaWQgPT4gaWQgIT09IG5vZGVJZCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHNldENhdXNhbFBhdGhNb2RlOiAoc3RhdGUsIGFjdGlvbikgPT4ge1xuICAgICAgc3RhdGUuY2F1c2FsUGF0aE1vZGUgPSBhY3Rpb24ucGF5bG9hZDtcbiAgICB9LFxuXG4gICAgc2V0Q2F1c2FsUGF0aE5vZGVzOiAoc3RhdGUsIGFjdGlvbikgPT4ge1xuICAgICAgc3RhdGUuY2F1c2FsUGF0aE5vZGVzID0gYWN0aW9uLnBheWxvYWQ7XG4gICAgfSxcblxuICAgIHNldENhdXNhbFBhdGhGb2NhbE5vZGU6IChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gICAgICBzdGF0ZS5jYXVzYWxQYXRoRm9jYWxOb2RlID0gYWN0aW9uLnBheWxvYWQ7XG4gICAgfSxcblxuICAgIGNsZWFyQ2F1c2FsUGF0aDogKHN0YXRlKSA9PiB7XG4gICAgICBzdGF0ZS5jYXVzYWxQYXRoTm9kZXMgPSBbXTtcbiAgICAgIHN0YXRlLmNhdXNhbFBhdGhGb2NhbE5vZGUgPSBudWxsO1xuICAgICAgc3RhdGUuY2F1c2FsUGF0aE1vZGUgPSBmYWxzZTtcbiAgICB9XG4gIH1cbn0pO1xuXG5leHBvcnQgY29uc3Qge1xuICBpbml0aWFsaXplQm9hcmQsXG4gIHVwZGF0ZUJvYXJkLFxuICBhZGRMaXN0LFxuICB1cGRhdGVMaXN0LFxuICBkZWxldGVMaXN0LFxuICByZW9yZGVyTGlzdHMsXG4gIGFkZE5vZGUsXG4gIHVwZGF0ZU5vZGUsXG4gIGRlbGV0ZU5vZGUsXG4gIHJlb3JkZXJOb2RlcyxcbiAgbW92ZU5vZGUsXG4gIGFkZEVkZ2UsXG4gIHVwZGF0ZUVkZ2UsXG4gIGRlbGV0ZUVkZ2UsXG4gIHNldExpbmtNb2RlLFxuICBzZXRMaW5rU291cmNlLFxuICBzZXRBY3RpdmVJZCxcbiAgc2V0RHJhZ1R5cGUsXG4gIHNldERyYWdnYWJsZU5vZGVzLFxuICB0b2dnbGVOb2RlRHJhZ2dhYmxlLFxuICBzZXRDYXVzYWxQYXRoTW9kZSxcbiAgc2V0Q2F1c2FsUGF0aE5vZGVzLFxuICBzZXRDYXVzYWxQYXRoRm9jYWxOb2RlLFxuICBjbGVhckNhdXNhbFBhdGhcbn0gPSBib2FyZFNsaWNlLmFjdGlvbnM7XG5cbmV4cG9ydCBkZWZhdWx0IGJvYXJkU2xpY2UucmVkdWNlcjtcblxuIl0sIm5hbWVzIjpbImNyZWF0ZVNsaWNlIiwiY3JlYXRlQm9hcmQiLCJpbml0aWFsU3RhdGUiLCJib2FyZCIsImxpbmtNb2RlIiwibGlua1NvdXJjZSIsImFjdGl2ZUlkIiwiZHJhZ1R5cGUiLCJkcmFnZ2FibGVOb2RlcyIsImNhdXNhbFBhdGhNb2RlIiwiY2F1c2FsUGF0aE5vZGVzIiwiY2F1c2FsUGF0aEZvY2FsTm9kZSIsImJvYXJkU2xpY2UiLCJuYW1lIiwicmVkdWNlcnMiLCJpbml0aWFsaXplQm9hcmQiLCJzdGF0ZSIsImFjdGlvbiIsInBheWxvYWQiLCJ1cGRhdGVCb2FyZCIsInVwZGF0ZWRBdCIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsImFkZExpc3QiLCJsaXN0cyIsInB1c2giLCJ1cGRhdGVMaXN0IiwibGlzdElkIiwidXBkYXRlcyIsImxpc3RJbmRleCIsImZpbmRJbmRleCIsImxpc3QiLCJpZCIsImRlbGV0ZUxpc3QiLCJmaWx0ZXIiLCJub2RlcyIsIm5vZGUiLCJyZW9yZGVyTGlzdHMiLCJkcmFnZ2VkSWQiLCJ0YXJnZXRJZCIsImRyYWdnZWRJbmRleCIsInRhcmdldEluZGV4IiwiZHJhZ2dlZExpc3QiLCJzcGxpY2UiLCJmb3JFYWNoIiwiaW5kZXgiLCJvcmRlciIsImFkZE5vZGUiLCJ1cGRhdGVOb2RlIiwibm9kZUlkIiwibm9kZUluZGV4IiwiZGVsZXRlTm9kZSIsImVkZ2VzIiwiZWRnZSIsInNvdXJjZUlkIiwicmVvcmRlck5vZGVzIiwibGlzdE5vZGVzIiwiZHJhZ2dlZE5vZGUiLCJuIiwibW92ZU5vZGUiLCJ0YXJnZXRMaXN0SWQiLCJ0YXJnZXRMaXN0Tm9kZXMiLCJuSW5kZXgiLCJhZGRFZGdlIiwidXBkYXRlRWRnZSIsImVkZ2VJZCIsImVkZ2VJbmRleCIsImRlbGV0ZUVkZ2UiLCJzZXRMaW5rTW9kZSIsInNldExpbmtTb3VyY2UiLCJzZXRBY3RpdmVJZCIsInNldERyYWdUeXBlIiwic2V0RHJhZ2dhYmxlTm9kZXMiLCJ0b2dnbGVOb2RlRHJhZ2dhYmxlIiwiaXNEcmFnZ2FibGUiLCJpbmNsdWRlcyIsInNldENhdXNhbFBhdGhNb2RlIiwic2V0Q2F1c2FsUGF0aE5vZGVzIiwic2V0Q2F1c2FsUGF0aEZvY2FsTm9kZSIsImNsZWFyQ2F1c2FsUGF0aCIsImFjdGlvbnMiLCJyZWR1Y2VyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/store/boardSlice.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/utils/tocModels.js":
/*!************************************!*\
  !*** ./src/app/utils/tocModels.js ***!
  \************************************/
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_LISTS: function() { return /* binding */ DEFAULT_LISTS; },\n/* harmony export */   EDGE_STYLES: function() { return /* binding */ EDGE_STYLES; },\n/* harmony export */   EDGE_TYPES: function() { return /* binding */ EDGE_TYPES; },\n/* harmony export */   LIST_TYPES: function() { return /* binding */ LIST_TYPES; },\n/* harmony export */   NODE_TYPES: function() { return /* binding */ NODE_TYPES; },\n/* harmony export */   createBoard: function() { return /* binding */ createBoard; },\n/* harmony export */   createEdge: function() { return /* binding */ createEdge; },\n/* harmony export */   createList: function() { return /* binding */ createList; },\n/* harmony export */   createNode: function() { return /* binding */ createNode; }\n/* harmony export */ });\n/**\n * Theory of Change data models and types\n */ // Default list types for Theory of Change\nconst DEFAULT_LISTS = [\n    {\n        id: \"activities\",\n        name: \"Activities\",\n        color: \"#3b82f6\",\n        order: 0,\n        type: \"fixed\"\n    },\n    {\n        id: \"outputs\",\n        name: \"Outputs\",\n        color: \"#10b981\",\n        order: 1,\n        type: \"fixed\"\n    },\n    {\n        id: \"intermediate-1\",\n        name: \"Intermediate Outcomes 1\",\n        color: \"#f59e0b\",\n        order: 2,\n        type: \"intermediate\"\n    },\n    {\n        id: \"final-outcomes\",\n        name: \"Final Outcomes\",\n        color: \"#ef4444\",\n        order: 3,\n        type: \"fixed\"\n    },\n    {\n        id: \"impact\",\n        name: \"Impact\",\n        color: \"#8b5cf6\",\n        order: 4,\n        type: \"fixed\"\n    }\n];\n// List types\nconst LIST_TYPES = {\n    FIXED: \"fixed\",\n    INTERMEDIATE: \"intermediate\"\n};\n// Node types\nconst NODE_TYPES = {\n    ACTIVITY: \"activity\",\n    OUTPUT: \"output\",\n    INTERMEDIATE_OUTCOME: \"intermediate_outcome\",\n    FINAL_OUTCOME: \"final_outcome\",\n    IMPACT: \"impact\"\n};\n// Edge types\nconst EDGE_TYPES = {\n    LEADS_TO: \"leads_to\",\n    ENABLES: \"enables\",\n    REQUIRES: \"requires\",\n    CONTRIBUTES_TO: \"contributes_to\"\n};\n// Default edge styles\nconst EDGE_STYLES = {\n    [EDGE_TYPES.LEADS_TO]: {\n        stroke: \"#1355bfff\",\n        strokeWidth: 2,\n        style: \"solid\",\n        label: \"leads to\"\n    },\n    [EDGE_TYPES.ENABLES]: {\n        stroke: \"#10b981\",\n        strokeWidth: 2,\n        style: \"dashed\",\n        label: \"enables\"\n    },\n    [EDGE_TYPES.REQUIRES]: {\n        stroke: \"#ef4444\",\n        strokeWidth: 2,\n        style: \"dotted\",\n        label: \"requires\"\n    },\n    [EDGE_TYPES.CONTRIBUTES_TO]: {\n        stroke: \"#f59e0b\",\n        strokeWidth: 2,\n        style: \"solid\",\n        label: \"contributes to\"\n    }\n};\n/**\n * Create a new board\n */ function createBoard() {\n    let name = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \"Theory of Change Board\";\n    const boardId = generateId();\n    // Create lists with proper IDs\n    const lists = DEFAULT_LISTS.map((list)=>({\n            ...list,\n            id: list.id,\n            nodeIds: []\n        }));\n    // Create sample nodes\n    const sampleNodes = [\n        // Activities\n        createNode(\"Community Training Workshops\", \"activities\", NODE_TYPES.ACTIVITY),\n        createNode(\"Teacher Professional Development\", \"activities\", NODE_TYPES.ACTIVITY),\n        createNode(\"Digital Learning Platform Development\", \"activities\", NODE_TYPES.ACTIVITY),\n        createNode(\"Curriculum Design and Review\", \"activities\", NODE_TYPES.ACTIVITY),\n        // Outputs\n        createNode(\"500 Teachers Trained\", \"outputs\", NODE_TYPES.OUTPUT),\n        createNode(\"Online Learning Platform Launched\", \"outputs\", NODE_TYPES.OUTPUT),\n        createNode(\"Updated Curriculum Materials\", \"outputs\", NODE_TYPES.OUTPUT),\n        createNode(\"Community Learning Centers Established\", \"outputs\", NODE_TYPES.OUTPUT),\n        // Intermediate Outcomes\n        createNode(\"Improved Teaching Quality\", \"intermediate-1\", NODE_TYPES.INTERMEDIATE_OUTCOME),\n        createNode(\"Increased Student Engagement\", \"intermediate-1\", NODE_TYPES.INTERMEDIATE_OUTCOME),\n        createNode(\"Enhanced Digital Literacy\", \"intermediate-1\", NODE_TYPES.INTERMEDIATE_OUTCOME),\n        // Final Outcomes\n        createNode(\"Improved Student Learning Outcomes\", \"final-outcomes\", NODE_TYPES.FINAL_OUTCOME),\n        createNode(\"Reduced Educational Inequality\", \"final-outcomes\", NODE_TYPES.FINAL_OUTCOME),\n        createNode(\"Increased School Completion Rates\", \"final-outcomes\", NODE_TYPES.FINAL_OUTCOME),\n        // Impact\n        createNode(\"Sustainable Community Development\", \"impact\", NODE_TYPES.IMPACT),\n        createNode(\"Reduced Poverty in Target Communities\", \"impact\", NODE_TYPES.IMPACT)\n    ];\n    // Set proper order for nodes within each list\n    sampleNodes.forEach((node, index)=>{\n        const listNodes = sampleNodes.filter((n)=>n.listId === node.listId);\n        const nodeIndexInList = listNodes.findIndex((n)=>n.id === node.id);\n        node.order = nodeIndexInList;\n        node.description = getNodeDescription(node.title, node.type);\n    });\n    // Create some sample edges to show relationships\n    const sampleEdges = [\n        createEdge(sampleNodes[0].id, sampleNodes[4].id, EDGE_TYPES.LEADS_TO),\n        createEdge(sampleNodes[1].id, sampleNodes[4].id, EDGE_TYPES.LEADS_TO),\n        createEdge(sampleNodes[2].id, sampleNodes[5].id, EDGE_TYPES.LEADS_TO),\n        createEdge(sampleNodes[4].id, sampleNodes[8].id, EDGE_TYPES.LEADS_TO),\n        createEdge(sampleNodes[5].id, sampleNodes[10].id, EDGE_TYPES.LEADS_TO),\n        createEdge(sampleNodes[8].id, sampleNodes[11].id, EDGE_TYPES.LEADS_TO),\n        createEdge(sampleNodes[11].id, sampleNodes[15].id, EDGE_TYPES.CONTRIBUTES_TO)\n    ];\n    return {\n        id: boardId,\n        name,\n        description: \"A sample Theory of Change for education improvement\",\n        lists,\n        nodes: sampleNodes,\n        edges: sampleEdges,\n        settings: {\n            showLabels: true,\n            snapToGrid: false,\n            autoLayout: true,\n            theme: \"light\"\n        },\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString()\n    };\n}\n/**\n * Get sample description for a node based on its type\n */ function getNodeDescription(title, type) {\n    const descriptions = {\n        [NODE_TYPES.ACTIVITY]: \"Key activity to implement the program\",\n        [NODE_TYPES.OUTPUT]: \"Direct result of program activities\",\n        [NODE_TYPES.INTERMEDIATE_OUTCOME]: \"Medium-term change resulting from outputs\",\n        [NODE_TYPES.FINAL_OUTCOME]: \"Long-term change we aim to achieve\",\n        [NODE_TYPES.IMPACT]: \"Ultimate societal change we contribute to\"\n    };\n    return descriptions[type] || \"Description for this node\";\n}\n/**\n * Create a new list\n */ function createList(name) {\n    let color = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"#6b7280\", order = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, type = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : \"intermediate\";\n    return {\n        id: generateId(),\n        name,\n        color,\n        order,\n        type,\n        collapsed: false,\n        nodeIds: []\n    };\n}\n/**\n * Create a new node\n */ function createNode(title, listId) {\n    let type = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : NODE_TYPES.ACTIVITY;\n    return {\n        id: generateId(),\n        title,\n        description: \"\",\n        listId,\n        type,\n        tags: [],\n        color: \"\",\n        priority: \"medium\",\n        order: 0,\n        position: {\n            x: 0,\n            y: 0\n        },\n        size: {\n            width: 200,\n            height: 100\n        },\n        collapsed: false,\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString()\n    };\n}\n/**\n * Create a new edge\n */ function createEdge(sourceId, targetId) {\n    let type = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : EDGE_TYPES.LEADS_TO;\n    return {\n        id: generateId(),\n        sourceId,\n        targetId,\n        type,\n        label: EDGE_STYLES[type].label,\n        style: EDGE_STYLES[type],\n        animated: false,\n        createdAt: new Date().toISOString()\n    };\n}\n/**\n * Generate a unique ID\n */ function generateId() {\n    return Math.random().toString(36).substr(2, 9);\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = __webpack_module__.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = __webpack_module__.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, __webpack_module__.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                __webpack_module__.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                __webpack_module__.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        __webpack_module__.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    __webpack_module__.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvdXRpbHMvdG9jTW9kZWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBOztDQUVDLEdBRUQsMENBQTBDO0FBQ25DLE1BQU1BLGdCQUFnQjtJQUMzQjtRQUFFQyxJQUFJO1FBQWNDLE1BQU07UUFBY0MsT0FBTztRQUFXQyxPQUFPO1FBQUdDLE1BQU07SUFBUTtJQUNsRjtRQUFFSixJQUFJO1FBQVdDLE1BQU07UUFBV0MsT0FBTztRQUFXQyxPQUFPO1FBQUdDLE1BQU07SUFBUTtJQUM1RTtRQUFFSixJQUFJO1FBQWtCQyxNQUFNO1FBQTJCQyxPQUFPO1FBQVdDLE9BQU87UUFBR0MsTUFBTTtJQUFlO0lBQzFHO1FBQUVKLElBQUk7UUFBa0JDLE1BQU07UUFBa0JDLE9BQU87UUFBV0MsT0FBTztRQUFHQyxNQUFNO0lBQVE7SUFDMUY7UUFBRUosSUFBSTtRQUFVQyxNQUFNO1FBQVVDLE9BQU87UUFBV0MsT0FBTztRQUFHQyxNQUFNO0lBQVE7Q0FDM0UsQ0FBQztBQUVGLGFBQWE7QUFDTixNQUFNQyxhQUFhO0lBQ3hCQyxPQUFPO0lBQ1BDLGNBQWM7QUFDaEIsRUFBRTtBQUVGLGFBQWE7QUFDTixNQUFNQyxhQUFhO0lBQ3hCQyxVQUFVO0lBQ1ZDLFFBQVE7SUFDUkMsc0JBQXNCO0lBQ3RCQyxlQUFlO0lBQ2ZDLFFBQVE7QUFDVixFQUFFO0FBRUYsYUFBYTtBQUNOLE1BQU1DLGFBQWE7SUFDeEJDLFVBQVU7SUFDVkMsU0FBUztJQUNUQyxVQUFVO0lBQ1ZDLGdCQUFnQjtBQUNsQixFQUFFO0FBRUYsc0JBQXNCO0FBQ2YsTUFBTUMsY0FBYztJQUN6QixDQUFDTCxXQUFXQyxRQUFRLENBQUMsRUFBRTtRQUNyQkssUUFBUTtRQUNSQyxhQUFhO1FBQ2JDLE9BQU87UUFDUEMsT0FBTztJQUNUO0lBQ0EsQ0FBQ1QsV0FBV0UsT0FBTyxDQUFDLEVBQUU7UUFDcEJJLFFBQVE7UUFDUkMsYUFBYTtRQUNiQyxPQUFPO1FB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Q1g5QixTQUFTLEVBQUU7SUFDYjtBQUNGO0FBRUE7O0NBRUMsR0FDTSxTQUFTRSxXQUFXWSxLQUFLLEVBQUVMLE1BQU07UUFBRW5DLE9BQUFBLGlFQUFPSSxXQUFXQyxRQUFRO0lBQ2xFLE9BQU87UUFDTFQsSUFBSTBCO1FBQ0prQjtRQUNBRixhQUFhO1FBQ2JIO1FBQ0FuQztRQUNBeUQsTUFBTSxFQUFFO1FBQ1IzRCxPQUFPO1FBQ1A0RCxVQUFVO1FBQ1YzRCxPQUFPO1FBQ1A0RCxVQUFVO1lBQUVDLEdBQUc7WUFBR0MsR0FBRztRQUFFO1FBQ3ZCQyxNQUFNO1lBQUVDLE9BQU87WUFBS0MsUUFBUTtRQUFJO1FBQ2hDUixXQUFXO1FBQ1hOLFdBQVcsSUFBSUMsT0FBT0MsV0FBVztRQUNqQ0MsV0FBVyxJQUFJRixPQUFPQyxXQUFXO0lBQ25DO0FBQ0Y7QUFFQTs7Q0FFQyxHQUNNLFNBQVNWLFdBQVd1QixRQUFRLEVBQUVDLFFBQVE7UUFBRWxFLE9BQUFBLGlFQUFPVSxXQUFXQyxRQUFRO0lBQ3ZFLE9BQU87UUFDTGYsSUFBSTBCO1FBQ0oyQztRQUNBQztRQUNBbEU7UUFDQW1CLE9BQU9KLFdBQVcsQ0FBQ2YsS0FBSyxDQUFDbUIsS0FBSztRQUM5QkQsT0FBT0gsV0FBVyxDQUFDZixLQUFLO1FBQ3hCbUUsVUFBVTtRQUNWakIsV0FBVyxJQUFJQyxPQUFPQyxXQUFXO0lBQ25DO0FBQ0Y7QUFFQTs7Q0FFQyxHQUNELFNBQVM5QjtJQUNQLE9BQU84QyxLQUFLQyxNQUFNLEdBQUdDLFFBQVEsQ0FBQyxJQUFJQyxNQUFNLENBQUMsR0FBRztBQUM5QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvYXBwL3V0aWxzL3RvY01vZGVscy5qcz81YmE5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVGhlb3J5IG9mIENoYW5nZSBkYXRhIG1vZGVscyBhbmQgdHlwZXNcbiAqL1xuXG4vLyBEZWZhdWx0IGxpc3QgdHlwZXMgZm9yIFRoZW9yeSBvZiBDaGFuZ2VcbmV4cG9ydCBjb25zdCBERUZBVUxUX0xJU1RTID0gW1xuICB7IGlkOiAnYWN0aXZpdGllcycsIG5hbWU6ICdBY3Rpdml0aWVzJywgY29sb3I6ICcjM2I4MmY2Jywgb3JkZXI6IDAsIHR5cGU6ICdmaXhlZCcgfSxcbiAgeyBpZDogJ291dHB1dHMnLCBuYW1lOiAnT3V0cHV0cycsIGNvbG9yOiAnIzEwYjk4MScsIG9yZGVyOiAxLCB0eXBlOiAnZml4ZWQnIH0sXG4gIHsgaWQ6ICdpbnRlcm1lZGlhdGUtMScsIG5hbWU6ICdJbnRlcm1lZGlhdGUgT3V0Y29tZXMgMScsIGNvbG9yOiAnI2Y1OWUwYicsIG9yZGVyOiAyLCB0eXBlOiAnaW50ZXJtZWRpYXRlJyB9LFxuICB7IGlkOiAnZmluYWwtb3V0Y29tZXMnLCBuYW1lOiAnRmluYWwgT3V0Y29tZXMnLCBjb2xvcjogJyNlZjQ0NDQnLCBvcmRlcjogMywgdHlwZTogJ2ZpeGVkJyB9LFxuICB7IGlkOiAnaW1wYWN0JywgbmFtZTogJ0ltcGFjdCcsIGNvbG9yOiAnIzhiNWNmNicsIG9yZGVyOiA0LCB0eXBlOiAnZml4ZWQnIH1cbl07XG5cbi8vIExpc3QgdHlwZXNcbmV4cG9ydCBjb25zdCBMSVNUX1RZUEVTID0ge1xuICBGSVhFRDogJ2ZpeGVkJyxcbiAgSU5URVJNRURJQVRFOiAnaW50ZXJtZWRpYXRlJ1xufTtcblxuLy8gTm9kZSB0eXBlc1xuZXhwb3J0IGNvbnN0IE5PREVfVFlQRVMgPSB7XG4gIEFDVElWSVRZOiAnYWN0aXZpdHknLFxuICBPVVRQVVQ6ICdvdXRwdXQnLFxuICBJTlRFUk1FRElBVEVfT1VUQ09NRTogJ2ludGVybWVkaWF0ZV9vdXRjb21lJyxcbiAgRklOQUxfT1VUQ09NRTogJ2ZpbmFsX291dGNvbWUnLFxuICBJTVBBQ1Q6ICdpbXBhY3QnXG59O1xuXG4vLyBFZGdlIHR5cGVzXG5leHBvcnQgY29uc3QgRURHRV9UWVBFUyA9IHtcbiAgTEVBRFNfVE86ICdsZWFkc190bycsXG4gIEVOQUJMRVM6ICdlbmFibGVzJyxcbiAgUkVRVUlSRVM6ICdyZXF1aXJlcycsXG4gIENPTlRSSUJVVEVTX1RPOiAnY29udHJpYnV0ZXNfdG8nXG59O1xuXG4vLyBEZWZhdWx0IGVkZ2Ugc3R5bGVzXG5leHBvcnQgY29uc3QgRURHRV9TVFlMRVMgPSB7XG4gIFtFREdFX1RZUEVTLkxFQURTX1RPXToge1xuICAgIHN0cm9rZTogJyMxMzU1YmZmZicsXG4gICAgc3Ryb2tlV2lkdGg6IDIsXG4gICAgc3R5bGU6ICdzb2xpZCcsXG4gICAgbGFiZWw6ICdsZWFkcyB0bydcbiAgfSxcbiAgW0VER0VfVFlQRVMuRU5BQkxFU106IHtcbiAgICBzdHJva2U6ICcjMTBiOTgxJyxcbiAgICBzdHJva2VXaWR0aDogMixcbiAgICBzdHlsZTogJ2Rhc2hlZCcsXG4gICAgbGFiZWw6ICdlbmFibGVzJ1xuICB9LFxuICBbRURHRV9UWVBFUy5SRVFVSVJFU106IHtcbiAgICBzdHJva2U6ICcjZWY0NDQ0JyxcbiAgICBzdHJva2VXaWR0aDogMixcbiAgICBzdHlsZTogJ2RvdHRlZCcsXG4gICAgbGFiZWw6ICdyZXF1aXJlcydcbiAgfSxcbiAgW0VER0VfVFlQRVMuQ09OVFJJQlVURVNfVE9dOiB7XG4gICAgc3Ryb2tlOiAnI2Y1OWUwYicsXG4gICAgc3Ryb2tlV2lkdGg6IDIsXG4gICAgc3R5bGU6ICdzb2xpZCcsXG4gICAgbGFiZWw6ICdjb250cmlidXRlcyB0bydcbiAgfVxufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgYm9hcmRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUJvYXJkKG5hbWUgPSAnVGhlb3J5IG9mIENoYW5nZSBCb2FyZCcpIHtcbiAgY29uc3QgYm9hcmRJZCA9IGdlbmVyYXRlSWQoKTtcbiAgXG4gIC8vIENyZWF0ZSBsaXN0cyB3aXRoIHByb3BlciBJRHNcbiAgY29uc3QgbGlzdHMgPSBERUZBVUxUX0xJU1RTLm1hcChsaXN0ID0+ICh7IFxuICAgIC4uLmxpc3QsIFxuICAgIGlkOiBsaXN0LmlkLCAvLyBLZWVwIHRoZSBwcmVkZWZpbmVkIElEcyBmb3IgY29uc2lzdGVuY3lcbiAgICBub2RlSWRzOiBbXVxuICB9KSk7XG5cbiAgLy8gQ3JlYXRlIHNhbXBsZSBub2Rlc1xuICBjb25zdCBzYW1wbGVOb2RlcyA9IFtcbiAgICAvLyBBY3Rpdml0aWVzXG4gICAgY3JlYXRlTm9kZSgnQ29tbXVuaXR5IFRyYWluaW5nIFdvcmtzaG9wcycsICdhY3Rpdml0aWVzJywgTk9ERV9UWVBFUy5BQ1RJVklUWSksXG4gICAgY3JlYXRlTm9kZSgnVGVhY2hlciBQcm9mZXNzaW9uYWwgRGV2ZWxvcG1lbnQnLCAnYWN0aXZpdGllcycsIE5PREVfVFlQRVMuQUNUSVZJVFkpLFxuICAgIGNyZWF0ZU5vZGUoJ0RpZ2l0YWwgTGVhcm5pbmcgUGxhdGZvcm0gRGV2ZWxvcG1lbnQnLCAnYWN0aXZpdGllcycsIE5PREVfVFlQRVMuQUNUSVZJVFkpLFxuICAgIGNyZWF0ZU5vZGUoJ0N1cnJpY3VsdW0gRGVzaWduIGFuZCBSZXZpZXcnLCAnYWN0aXZpdGllcycsIE5PREVfVFlQRVMuQUNUSVZJVFkpLFxuICAgIFxuICAgIC8vIE91dHB1dHNcbiAgICBjcmVhdGVOb2RlKCc1MDAgVGVhY2hlcnMgVHJhaW5lZCcsICdvdXRwdXRzJywgTk9ERV9UWVBFUy5PVVRQVVQpLFxuICAgIGNyZWF0ZU5vZGUoJ09ubGluZSBMZWFybmluZyBQbGF0Zm9ybSBMYXVuY2hlZCcsICdvdXRwdXRzJywgTk9ERV9UWVBFUy5PVVRQVVQpLFxuICAgIGNyZWF0ZU5vZGUoJ1VwZGF0ZWQgQ3VycmljdWx1bSBNYXRlcmlhbHMnLCAnb3V0cHV0cycsIE5PREVfVFlQRVMuT1VUUFVUKSxcbiAgICBjcmVhdGVOb2RlKCdDb21tdW5pdHkgTGVhcm5pbmcgQ2VudGVycyBFc3RhYmxpc2hlZCcsICdvdXRwdXRzJywgTk9ERV9UWVBFUy5PVVRQVVQpLFxuICAgIFxuICAgIC8vIEludGVybWVkaWF0ZSBPdXRjb21lc1xuICAgIGNyZWF0ZU5vZGUoJ0ltcHJvdmVkIFRlYWNoaW5nIFF1YWxpdHknLCAnaW50ZXJtZWRpYXRlLTEnLCBOT0RFX1RZUEVTLklOVEVSTUVESUFURV9PVVRDT01FKSxcbiAgICBjcmVhdGVOb2RlKCdJbmNyZWFzZWQgU3R1ZGVudCBFbmdhZ2VtZW50JywgJ2ludGVybWVkaWF0ZS0xJywgTk9ERV9UWVBFUy5JTlRFUk1FRElBVEVfT1VUQ09NRSksXG4gICAgY3JlYXRlTm9kZSgnRW5oYW5jZWQgRGlnaXRhbCBMaXRlcmFjeScsICdpbnRlcm1lZGlhdGUtMScsIE5PREVfVFlQRVMuSU5URVJNRURJQVRFX09VVENPTUUpLFxuICAgIFxuICAgIC8vIEZpbmFsIE91dGNvbWVzXG4gICAgY3JlYXRlTm9kZSgnSW1wcm92ZWQgU3R1ZGVudCBMZWFybmluZyBPdXRjb21lcycsICdmaW5hbC1vdXRjb21lcycsIE5PREVfVFlQRVMuRklOQUxfT1VUQ09NRSksXG4gICAgY3JlYXRlTm9kZSgnUmVkdWNlZCBFZHVjYXRpb25hbCBJbmVxdWFsaXR5JywgJ2ZpbmFsLW91dGNvbWVzJywgTk9ERV9UWVBFUy5GSU5BTF9PVVRDT01FKSxcbiAgICBjcmVhdGVOb2RlKCdJbmNyZWFzZWQgU2Nob29sIENvbXBsZXRpb24gUmF0ZXMnLCAnZmluYWwtb3V0Y29tZXMnLCBOT0RFX1RZUEVTLkZJTkFMX09VVENPTUUpLFxuICAgIFxuICAgIC8vIEltcGFjdFxuICAgIGNyZWF0ZU5vZGUoJ1N1c3RhaW5hYmxlIENvbW11bml0eSBEZXZlbG9wbWVudCcsICdpbXBhY3QnLCBOT0RFX1RZUEVTLklNUEFDVCksXG4gICAgY3JlYXRlTm9kZSgnUmVkdWNlZCBQb3ZlcnR5IGluIFRhcmdldCBDb21tdW5pdGllcycsICdpbXBhY3QnLCBOT0RFX1RZUEVTLklNUEFDVClcbiAgXTtcblxuICAvLyBTZXQgcHJvcGVyIG9yZGVyIGZvciBub2RlcyB3aXRoaW4gZWFjaCBsaXN0XG4gIHNhbXBsZU5vZGVzLmZvckVhY2goKG5vZGUsIGluZGV4KSA9PiB7XG4gICAgY29uc3QgbGlzdE5vZGVzID0gc2FtcGxlTm9kZXMuZmlsdGVyKG4gPT4gbi5saXN0SWQgPT09IG5vZGUubGlzdElkKTtcbiAgICBjb25zdCBub2RlSW5kZXhJbkxpc3QgPSBsaXN0Tm9kZXMuZmluZEluZGV4KG4gPT4gbi5pZCA9PT0gbm9kZS5pZCk7XG4gICAgbm9kZS5vcmRlciA9IG5vZGVJbmRleEluTGlzdDtcbiAgICBub2RlLmRlc2NyaXB0aW9uID0gZ2V0Tm9kZURlc2NyaXB0aW9uKG5vZGUudGl0bGUsIG5vZGUudHlwZSk7XG4gIH0pO1xuXG4gIC8vIENyZWF0ZSBzb21lIHNhbXBsZSBlZGdlcyB0byBzaG93IHJlbGF0aW9uc2hpcHNcbiAgY29uc3Qgc2FtcGxlRWRnZXMgPSBbXG4gICAgY3JlYXRlRWRnZShzYW1wbGVOb2Rlc1swXS5pZCwgc2FtcGxlTm9kZXNbNF0uaWQsIEVER0VfVFlQRVMuTEVBRFNfVE8pLCAvLyBUcmFpbmluZyAtPiBUZWFjaGVycyBUcmFpbmVkXG4gICAgY3JlYXRlRWRnZShzYW1wbGVOb2Rlc1sxXS5pZCwgc2FtcGxlTm9kZXNbNF0uaWQsIEVER0VfVFlQRVMuTEVBRFNfVE8pLCAvLyBQcm9mIERldiAtPiBUZWFjaGVycyBUcmFpbmVkXG4gICAgY3JlYXRlRWRnZShzYW1wbGVOb2Rlc1syXS5pZCwgc2FtcGxlTm9kZXNbNV0uaWQsIEVER0VfVFlQRVMuTEVBRFNfVE8pLCAvLyBQbGF0Zm9ybSBEZXYgLT4gUGxhdGZvcm0gTGF1bmNoZWRcbiAgICBjcmVhdGVFZGdlKHNhbXBsZU5vZGVzWzRdLmlkLCBzYW1wbGVOb2Rlc1s4XS5pZCwgRURHRV9UWVBFUy5MRUFEU19UTyksIC8vIFRlYWNoZXJzIFRyYWluZWQgLT4gVGVhY2hpbmcgUXVhbGl0eVxuICAgIGNyZWF0ZUVkZ2Uoc2FtcGxlTm9kZXNbNV0uaWQsIHNhbXBsZU5vZGVzWzEwXS5pZCwgRURHRV9UWVBFUy5MRUFEU19UTyksIC8vIFBsYXRmb3JtIC0+IERpZ2l0YWwgTGl0ZXJhY3lcbiAgICBjcmVhdGVFZGdlKHNhbXBsZU5vZGVzWzhdLmlkLCBzYW1wbGVOb2Rlc1sxMV0uaWQsIEVER0VfVFlQRVMuTEVBRFNfVE8pLCAvLyBUZWFjaGluZyBRdWFsaXR5IC0+IExlYXJuaW5nIE91dGNvbWVzXG4gICAgY3JlYXRlRWRnZShzYW1wbGVOb2Rlc1sxMV0uaWQsIHNhbXBsZU5vZGVzWzE1XS5pZCwgRURHRV9UWVBFUy5DT05UUklCVVRFU19UTyksIC8vIExlYXJuaW5nIC0+IERldmVsb3BtZW50XG4gIF07XG5cbiAgcmV0dXJuIHtcbiAgICBpZDogYm9hcmRJZCxcbiAgICBuYW1lLFxuICAgIGRlc2NyaXB0aW9uOiAnQSBzYW1wbGUgVGhlb3J5IG9mIENoYW5nZSBmb3IgZWR1Y2F0aW9uIGltcHJvdmVtZW50JyxcbiAgICBsaXN0cyxcbiAgICBub2Rlczogc2FtcGxlTm9kZXMsXG4gICAgZWRnZXM6IHNhbXBsZUVkZ2VzLFxuICAgIHNldHRpbmdzOiB7XG4gICAgICBzaG93TGFiZWxzOiB0cnVlLFxuICAgICAgc25hcFRvR3JpZDogZmFsc2UsXG4gICAgICBhdXRvTGF5b3V0OiB0cnVlLFxuICAgICAgdGhlbWU6ICdsaWdodCdcbiAgICB9LFxuICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gIH07XG59XG5cbi8qKlxuICogR2V0IHNhbXBsZSBkZXNjcmlwdGlvbiBmb3IgYSBub2RlIGJhc2VkIG9uIGl0cyB0eXBlXG4gKi9cbmZ1bmN0aW9uIGdldE5vZGVEZXNjcmlwdGlvbih0aXRsZSwgdHlwZSkge1xuICBjb25zdCBkZXNjcmlwdGlvbnMgPSB7XG4gICAgW05PREVfVFlQRVMuQUNUSVZJVFldOiAnS2V5IGFjdGl2aXR5IHRvIGltcGxlbWVudCB0aGUgcHJvZ3JhbScsXG4gICAgW05PREVfVFlQRVMuT1VUUFVUXTogJ0RpcmVjdCByZXN1bHQgb2YgcHJvZ3JhbSBhY3Rpdml0aWVzJyxcbiAgICBbTk9ERV9UWVBFUy5JTlRFUk1FRElBVEVfT1VUQ09NRV06ICdNZWRpdW0tdGVybSBjaGFuZ2UgcmVzdWx0aW5nIGZyb20gb3V0cHV0cycsXG4gICAgW05PREVfVFlQRVMuRklOQUxfT1VUQ09NRV06ICdMb25nLXRlcm0gY2hhbmdlIHdlIGFpbSB0byBhY2hpZXZlJyxcbiAgICBbTk9ERV9UWVBFUy5JTVBBQ1RdOiAnVWx0aW1hdGUgc29jaWV0YWwgY2hhbmdlIHdlIGNvbnRyaWJ1dGUgdG8nXG4gIH07XG4gIHJldHVybiBkZXNjcmlwdGlvbnNbdHlwZV0gfHwgJ0Rlc2NyaXB0aW9uIGZvciB0aGlzIG5vZGUnO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBsaXN0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVMaXN0KG5hbWUsIGNvbG9yID0gJyM2YjcyODAnLCBvcmRlciA9IDAsIHR5cGUgPSAnaW50ZXJtZWRpYXRlJykge1xuICByZXR1cm4ge1xuICAgIGlkOiBnZW5lcmF0ZUlkKCksXG4gICAgbmFtZSxcbiAgICBjb2xvcixcbiAgICBvcmRlcixcbiAgICB0eXBlLFxuICAgIGNvbGxhcHNlZDogZmFsc2UsXG4gICAgbm9kZUlkczogW11cbiAgfTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgbm9kZVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTm9kZSh0aXRsZSwgbGlzdElkLCB0eXBlID0gTk9ERV9UWVBFUy5BQ1RJVklUWSkge1xuICByZXR1cm4ge1xuICAgIGlkOiBnZW5lcmF0ZUlkKCksXG4gICAgdGl0bGUsXG4gICAgZGVzY3JpcHRpb246ICcnLFxuICAgIGxpc3RJZCxcbiAgICB0eXBlLFxuICAgIHRhZ3M6IFtdLFxuICAgIGNvbG9yOiAnJyxcbiAgICBwcmlvcml0eTogJ21lZGl1bScsXG4gICAgb3JkZXI6IDAsIC8vIEZvciBzb3J0aW5nIHdpdGhpbiBsaXN0XG4gICAgcG9zaXRpb246IHsgeDogMCwgeTogMCB9LCAvLyBGb3IgdmlzdWFsIHBvc2l0aW9uaW5nXG4gICAgc2l6ZTogeyB3aWR0aDogMjAwLCBoZWlnaHQ6IDEwMCB9LFxuICAgIGNvbGxhcHNlZDogZmFsc2UsXG4gICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgfTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgZWRnZVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRWRnZShzb3VyY2VJZCwgdGFyZ2V0SWQsIHR5cGUgPSBFREdFX1RZUEVTLkxFQURTX1RPKSB7XG4gIHJldHVybiB7XG4gICAgaWQ6IGdlbmVyYXRlSWQoKSxcbiAgICBzb3VyY2VJZCxcbiAgICB0YXJnZXRJZCxcbiAgICB0eXBlLFxuICAgIGxhYmVsOiBFREdFX1NUWUxFU1t0eXBlXS5sYWJlbCxcbiAgICBzdHlsZTogRURHRV9TVFlMRVNbdHlwZV0sXG4gICAgYW5pbWF0ZWQ6IGZhbHNlLFxuICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gIH07XG59XG5cbi8qKlxuICogR2VuZXJhdGUgYSB1bmlxdWUgSURcbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVJZCgpIHtcbiAgcmV0dXJuIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyLCA5KTtcbn0iXSwibmFtZXMiOlsiREVGQVVMVF9MSVNUUyIsImlkIiwibmFtZSIsImNvbG9yIiwib3JkZXIiLCJ0eXBlIiwiTElTVF9UWVBFUyIsIkZJWEVEIiwiSU5URVJNRURJQVRFIiwiTk9ERV9UWVBFUyIsIkFDVElWSVRZIiwiT1VUUFVUIiwiSU5URVJNRURJQVRFX09VVENPTUUiLCJGSU5BTF9PVVRDT01FIiwiSU1QQUNUIiwiRURHRV9UWVBFUyIsIkxFQURTX1RPIiwiRU5BQkxFUyIsIlJFUVVJUkVTIiwiQ09OVFJJQlVURVNfVE8iLCJFREdFX1NUWUxFUyIsInN0cm9rZSIsInN0cm9rZVdpZHRoIiwic3R5bGUiLCJsYWJlbCIsImNyZWF0ZUJvYXJkIiwiYm9hcmRJZCIsImdlbmVyYXRlSWQiLCJsaXN0cyIsIm1hcCIsImxpc3QiLCJub2RlSWRzIiwic2FtcGxlTm9kZXMiLCJjcmVhdGVOb2RlIiwiZm9yRWFjaCIsIm5vZGUiLCJpbmRleCIsImxpc3ROb2RlcyIsImZpbHRlciIsIm4iLCJsaXN0SWQiLCJub2RlSW5kZXhJbkxpc3QiLCJmaW5kSW5kZXgiLCJkZXNjcmlwdGlvbiIsImdldE5vZGVEZXNjcmlwdGlvbiIsInRpdGxlIiwic2FtcGxlRWRnZXMiLCJjcmVhdGVFZGdlIiwibm9kZXMiLCJlZGdlcyIsInNldHRpbmdzIiwic2hvd0xhYmVscyIsInNuYXBUb0dyaWQiLCJhdXRvTGF5b3V0IiwidGhlbWUiLCJjcmVhdGVkQXQiLCJEYXRlIiwidG9JU09TdHJpbmciLCJ1cGRhdGVkQXQiLCJkZXNjcmlwdGlvbnMiLCJjcmVhdGVMaXN0IiwiY29sbGFwc2VkIiwidGFncyIsInByaW9yaXR5IiwicG9zaXRpb24iLCJ4IiwieSIsInNpemUiLCJ3aWR0aCIsImhlaWdodCIsInNvdXJjZUlkIiwidGFyZ2V0SWQiLCJhbmltYXRlZCIsIk1hdGgiLCJyYW5kb20iLCJ0b1N0cmluZyIsInN1YnN0ciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/utils/tocModels.js\n"));

/***/ })

});