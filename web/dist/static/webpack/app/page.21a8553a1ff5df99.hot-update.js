"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/app/utils/tocModels.js":
/*!************************************!*\
  !*** ./src/app/utils/tocModels.js ***!
  \************************************/
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_LISTS: function() { return /* binding */ DEFAULT_LISTS; },\n/* harmony export */   EDGE_STYLES: function() { return /* binding */ EDGE_STYLES; },\n/* harmony export */   EDGE_TYPES: function() { return /* binding */ EDGE_TYPES; },\n/* harmony export */   LIST_TYPES: function() { return /* binding */ LIST_TYPES; },\n/* harmony export */   NODE_TYPES: function() { return /* binding */ NODE_TYPES; },\n/* harmony export */   createBoard: function() { return /* binding */ createBoard; },\n/* harmony export */   createEdge: function() { return /* binding */ createEdge; },\n/* harmony export */   createList: function() { return /* binding */ createList; },\n/* harmony export */   createNode: function() { return /* binding */ createNode; },\n/* harmony export */   createSection: function() { return /* binding */ createSection; }\n/* harmony export */ });\n/**\n * Theory of Change data models and types\n */ // Default list types for Theory of Change\nconst DEFAULT_LISTS = [\n    {\n        id: \"activities\",\n        name: \"Activities\",\n        color: \"#3b82f6\",\n        order: 0,\n        type: \"fixed\"\n    },\n    {\n        id: \"outputs\",\n        name: \"Outputs\",\n        color: \"#10b981\",\n        order: 1,\n        type: \"fixed\"\n    },\n    {\n        id: \"intermediate-1\",\n        name: \"Intermediate Outcomes 1\",\n        color: \"#f59e0b\",\n        order: 2,\n        type: \"intermediate\"\n    },\n    {\n        id: \"final-outcomes\",\n        name: \"Final Outcomes\",\n        color: \"#ef4444\",\n        order: 3,\n        type: \"fixed\"\n    },\n    {\n        id: \"impact\",\n        name: \"Impact\",\n        color: \"#8b5cf6\",\n        order: 4,\n        type: \"fixed\"\n    }\n];\n// List types\nconst LIST_TYPES = {\n    FIXED: \"fixed\",\n    INTERMEDIATE: \"intermediate\"\n};\n// Node types\nconst NODE_TYPES = {\n    ACTIVITY: \"activity\",\n    OUTPUT: \"output\",\n    INTERMEDIATE_OUTCOME: \"intermediate_outcome\",\n    FINAL_OUTCOME: \"final_outcome\",\n    IMPACT: \"impact\"\n};\n// Edge types\nconst EDGE_TYPES = {\n    LEADS_TO: \"leads_to\",\n    ENABLES: \"enables\",\n    REQUIRES: \"requires\",\n    CONTRIBUTES_TO: \"contributes_to\"\n};\n// Default edge styles\nconst EDGE_STYLES = {\n    [EDGE_TYPES.LEADS_TO]: {\n        stroke: \"#1355bfff\",\n        strokeWidth: 2,\n        style: \"solid\",\n        label: \"leads to\"\n    },\n    [EDGE_TYPES.ENABLES]: {\n        stroke: \"#10b981\",\n        strokeWidth: 2,\n        style: \"dashed\",\n        label: \"enables\"\n    },\n    [EDGE_TYPES.REQUIRES]: {\n        stroke: \"#ef4444\",\n        strokeWidth: 2,\n        style: \"dotted\",\n        label: \"requires\"\n    },\n    [EDGE_TYPES.CONTRIBUTES_TO]: {\n        stroke: \"#f59e0b\",\n        strokeWidth: 2,\n        style: \"solid\",\n        label: \"contributes to\"\n    }\n};\n/**\n * Create a new board\n */ function createBoard() {\n    let name = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \"Theory of Change Board\";\n    const boardId = generateId();\n    // Create lists with proper IDs and default sections\n    const lists = DEFAULT_LISTS.map((list)=>{\n        const defaultSection = createSection(\"Ungrouped\", list.id, 0);\n        return {\n            ...list,\n            id: list.id,\n            nodeIds: [],\n            sections: [\n                defaultSection\n            ]\n        };\n    });\n    // Create sample nodes\n    const sampleNodes = [\n        // Activities\n        createNode(\"Community Training Workshops\", \"activities\", NODE_TYPES.ACTIVITY),\n        createNode(\"Teacher Professional Development\", \"activities\", NODE_TYPES.ACTIVITY),\n        createNode(\"Digital Learning Platform Development\", \"activities\", NODE_TYPES.ACTIVITY),\n        createNode(\"Curriculum Design and Review\", \"activities\", NODE_TYPES.ACTIVITY),\n        // Outputs\n        createNode(\"500 Teachers Trained\", \"outputs\", NODE_TYPES.OUTPUT),\n        createNode(\"Online Learning Platform Launched\", \"outputs\", NODE_TYPES.OUTPUT),\n        createNode(\"Updated Curriculum Materials\", \"outputs\", NODE_TYPES.OUTPUT),\n        createNode(\"Community Learning Centers Established\", \"outputs\", NODE_TYPES.OUTPUT),\n        // Intermediate Outcomes\n        createNode(\"Improved Teaching Quality\", \"intermediate-1\", NODE_TYPES.INTERMEDIATE_OUTCOME),\n        createNode(\"Increased Student Engagement\", \"intermediate-1\", NODE_TYPES.INTERMEDIATE_OUTCOME),\n        createNode(\"Enhanced Digital Literacy\", \"intermediate-1\", NODE_TYPES.INTERMEDIATE_OUTCOME),\n        // Final Outcomes\n        createNode(\"Improved Student Learning Outcomes\", \"final-outcomes\", NODE_TYPES.FINAL_OUTCOME),\n        createNode(\"Reduced Educational Inequality\", \"final-outcomes\", NODE_TYPES.FINAL_OUTCOME),\n        createNode(\"Increased School Completion Rates\", \"final-outcomes\", NODE_TYPES.FINAL_OUTCOME),\n        // Impact\n        createNode(\"Sustainable Community Development\", \"impact\", NODE_TYPES.IMPACT),\n        createNode(\"Reduced Poverty in Target Communities\", \"impact\", NODE_TYPES.IMPACT)\n    ];\n    // Set proper order for nodes within each list\n    sampleNodes.forEach((node, index)=>{\n        const listNodes = sampleNodes.filter((n)=>n.listId === node.listId);\n        const nodeIndexInList = listNodes.findIndex((n)=>n.id === node.id);\n        node.order = nodeIndexInList;\n        node.description = getNodeDescription(node.title, node.type);\n    });\n    // Create some sample edges to show relationships\n    const sampleEdges = [\n        createEdge(sampleNodes[0].id, sampleNodes[4].id, EDGE_TYPES.LEADS_TO),\n        createEdge(sampleNodes[1].id, sampleNodes[4].id, EDGE_TYPES.LEADS_TO),\n        createEdge(sampleNodes[2].id, sampleNodes[5].id, EDGE_TYPES.LEADS_TO),\n        createEdge(sampleNodes[4].id, sampleNodes[8].id, EDGE_TYPES.LEADS_TO),\n        createEdge(sampleNodes[5].id, sampleNodes[10].id, EDGE_TYPES.LEADS_TO),\n        createEdge(sampleNodes[8].id, sampleNodes[11].id, EDGE_TYPES.LEADS_TO),\n        createEdge(sampleNodes[11].id, sampleNodes[15].id, EDGE_TYPES.CONTRIBUTES_TO)\n    ];\n    return {\n        id: boardId,\n        name,\n        description: \"A sample Theory of Change for education improvement\",\n        lists,\n        nodes: sampleNodes,\n        edges: sampleEdges,\n        settings: {\n            showLabels: true,\n            snapToGrid: false,\n            autoLayout: true,\n            theme: \"light\"\n        },\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString()\n    };\n}\n/**\n * Get sample description for a node based on its type\n */ function getNodeDescription(title, type) {\n    const descriptions = {\n        [NODE_TYPES.ACTIVITY]: \"Key activity to implement the program\",\n        [NODE_TYPES.OUTPUT]: \"Direct result of program activities\",\n        [NODE_TYPES.INTERMEDIATE_OUTCOME]: \"Medium-term change resulting from outputs\",\n        [NODE_TYPES.FINAL_OUTCOME]: \"Long-term change we aim to achieve\",\n        [NODE_TYPES.IMPACT]: \"Ultimate societal change we contribute to\"\n    };\n    return descriptions[type] || \"Description for this node\";\n}\n/**\n * Create a new section within a list\n */ function createSection() {\n    let name = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \"Ungrouped\", listId = arguments.length > 1 ? arguments[1] : void 0, order = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;\n    return {\n        id: generateId(),\n        name,\n        listId,\n        order,\n        collapsed: false,\n        createdAt: new Date().toISOString()\n    };\n}\n/**\n * Create a new list\n */ function createList(name) {\n    let color = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"#6b7280\", order = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, type = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : \"intermediate\";\n    const listId = generateId();\n    // Create default \"Ungrouped\" section for the list\n    const defaultSection = createSection(\"Ungrouped\", listId, 0);\n    return {\n        id: listId,\n        name,\n        color,\n        order,\n        type,\n        collapsed: false,\n        nodeIds: [],\n        sections: [\n            defaultSection\n        ]\n    };\n}\n/**\n * Create a new node\n */ function createNode(title, listId) {\n    let type = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : NODE_TYPES.ACTIVITY, sectionId = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;\n    return {\n        id: generateId(),\n        title,\n        description: \"\",\n        listId,\n        sectionId,\n        type,\n        tags: [],\n        color: \"\",\n        priority: \"medium\",\n        order: 0,\n        position: {\n            x: 0,\n            y: 0\n        },\n        size: {\n            width: 200,\n            height: 100\n        },\n        collapsed: false,\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString()\n    };\n}\n/**\n * Create a new edge\n */ function createEdge(sourceId, targetId) {\n    let type = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : EDGE_TYPES.LEADS_TO;\n    return {\n        id: generateId(),\n        sourceId,\n        targetId,\n        type,\n        label: EDGE_STYLES[type].label,\n        style: EDGE_STYLES[type],\n        animated: false,\n        createdAt: new Date().toISOString()\n    };\n}\n/**\n * Generate a unique ID\n */ function generateId() {\n    return Math.random().toString(36).substr(2, 9);\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = __webpack_module__.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = __webpack_module__.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, __webpack_module__.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                __webpack_module__.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                __webpack_module__.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        __webpack_module__.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    __webpack_module__.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvdXRpbHMvdG9jTW9kZWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Q0FFQyxHQUVELDBDQUEwQztBQUNuQyxNQUFNQSxnQkFBZ0I7SUFDM0I7UUFBRUMsSUFBSTtRQUFjQyxNQUFNO1FBQWNDLE9BQU87UUFBV0MsT0FBTztRQUFHQyxNQUFNO0lBQVE7SUFDbEY7UUFBRUosSUFBSTtRQUFXQyxNQUFNO1FBQVdDLE9BQU87UUFBV0MsT0FBTztRQUFHQyxNQUFNO0lBQVE7SUFDNUU7UUFBRUosSUFBSTtRQUFrQkMsTUFBTTtRQUEyQkMsT0FBTztRQUFXQyxPQUFPO1FBQUdDLE1BQU07SUFBZTtJQUMxRztRQUFFSixJQUFJO1FBQWtCQyxNQUFNO1FBQWtCQyxPQUFPO1FBQVdDLE9BQU87UUFBR0MsTUFBTTtJQUFRO0lBQzFGO1FBQUVKLElBQUk7UUFBVUMsTUFBTTtRQUFVQyxPQUFPO1FBQVdDLE9BQU87UUFBR0MsTUFBTTtJQUFRO0NBQzNFLENBQUM7QUFFRixhQUFhO0FBQ04sTUFBTUMsYUFBYTtJQUN4QkMsT0FBTztJQUNQQyxjQUFjO0FBQ2hCLEVBQUU7QUFFRixhQUFhO0FBQ04sTUFBTUMsYUFBYTtJQUN4QkMsVUFBVTtJQUNWQyxRQUFRO0lBQ1JDLHNCQUFzQjtJQUN0QkMsZUFBZTtJQUNmQyxRQUFRO0FBQ1YsRUFBRTtBQUVGLGFBQWE7QUFDTixNQUFNQyxhQUFhO0lBQ3hCQyxVQUFVO0lBQ1ZDLFNBQVM7SUFDVEMsVUFBVTtJQUNWQyxnQkFBZ0I7QUFDbEIsRUFBRTtBQUVGLHNCQUFzQjtBQUNmLE1BQU1DLGNBQWM7SUFDekIsQ0FBQ0wsV0FBV0MsUUFBUSxDQUFDLEVBQUU7UUFDckJLLFFBQVE7UUFDUkMsYUFBYTtRQUNiQyxPQUFPO1FBQ1BDLE9BQU87SUFDVDtJQUNBLENBQUNULFdBQVdFLE9BQU8sQ0FBQyxFQUFFO1FBQ3BCSSxRQUFRO1FBQ1JDLGFBQWE7UUFDYkMsT0FBTztR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RCxPQUFPSCxXQUFXLENBQUNmLEtBQUs7UUFDeEJ1RSxVQUFVO1FBQ1ZsQixXQUFXLElBQUlDLE9BQU9DLFdBQVc7SUFDbkM7QUFDRjtBQUVBOztDQUVDLEdBQ0QsU0FBU2pDO0lBQ1AsT0FBT2tELEtBQUtDLE1BQU0sR0FBR0MsUUFBUSxDQUFDLElBQUlDLE1BQU0sQ0FBQyxHQUFHO0FBQzlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9hcHAvdXRpbHMvdG9jTW9kZWxzLmpzPzViYTkiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBUaGVvcnkgb2YgQ2hhbmdlIGRhdGEgbW9kZWxzIGFuZCB0eXBlc1xuICovXG5cbi8vIERlZmF1bHQgbGlzdCB0eXBlcyBmb3IgVGhlb3J5IG9mIENoYW5nZVxuZXhwb3J0IGNvbnN0IERFRkFVTFRfTElTVFMgPSBbXG4gIHsgaWQ6ICdhY3Rpdml0aWVzJywgbmFtZTogJ0FjdGl2aXRpZXMnLCBjb2xvcjogJyMzYjgyZjYnLCBvcmRlcjogMCwgdHlwZTogJ2ZpeGVkJyB9LFxuICB7IGlkOiAnb3V0cHV0cycsIG5hbWU6ICdPdXRwdXRzJywgY29sb3I6ICcjMTBiOTgxJywgb3JkZXI6IDEsIHR5cGU6ICdmaXhlZCcgfSxcbiAgeyBpZDogJ2ludGVybWVkaWF0ZS0xJywgbmFtZTogJ0ludGVybWVkaWF0ZSBPdXRjb21lcyAxJywgY29sb3I6ICcjZjU5ZTBiJywgb3JkZXI6IDIsIHR5cGU6ICdpbnRlcm1lZGlhdGUnIH0sXG4gIHsgaWQ6ICdmaW5hbC1vdXRjb21lcycsIG5hbWU6ICdGaW5hbCBPdXRjb21lcycsIGNvbG9yOiAnI2VmNDQ0NCcsIG9yZGVyOiAzLCB0eXBlOiAnZml4ZWQnIH0sXG4gIHsgaWQ6ICdpbXBhY3QnLCBuYW1lOiAnSW1wYWN0JywgY29sb3I6ICcjOGI1Y2Y2Jywgb3JkZXI6IDQsIHR5cGU6ICdmaXhlZCcgfVxuXTtcblxuLy8gTGlzdCB0eXBlc1xuZXhwb3J0IGNvbnN0IExJU1RfVFlQRVMgPSB7XG4gIEZJWEVEOiAnZml4ZWQnLFxuICBJTlRFUk1FRElBVEU6ICdpbnRlcm1lZGlhdGUnXG59O1xuXG4vLyBOb2RlIHR5cGVzXG5leHBvcnQgY29uc3QgTk9ERV9UWVBFUyA9IHtcbiAgQUNUSVZJVFk6ICdhY3Rpdml0eScsXG4gIE9VVFBVVDogJ291dHB1dCcsXG4gIElOVEVSTUVESUFURV9PVVRDT01FOiAnaW50ZXJtZWRpYXRlX291dGNvbWUnLFxuICBGSU5BTF9PVVRDT01FOiAnZmluYWxfb3V0Y29tZScsXG4gIElNUEFDVDogJ2ltcGFjdCdcbn07XG5cbi8vIEVkZ2UgdHlwZXNcbmV4cG9ydCBjb25zdCBFREdFX1RZUEVTID0ge1xuICBMRUFEU19UTzogJ2xlYWRzX3RvJyxcbiAgRU5BQkxFUzogJ2VuYWJsZXMnLFxuICBSRVFVSVJFUzogJ3JlcXVpcmVzJyxcbiAgQ09OVFJJQlVURVNfVE86ICdjb250cmlidXRlc190bydcbn07XG5cbi8vIERlZmF1bHQgZWRnZSBzdHlsZXNcbmV4cG9ydCBjb25zdCBFREdFX1NUWUxFUyA9IHtcbiAgW0VER0VfVFlQRVMuTEVBRFNfVE9dOiB7XG4gICAgc3Ryb2tlOiAnIzEzNTViZmZmJyxcbiAgICBzdHJva2VXaWR0aDogMixcbiAgICBzdHlsZTogJ3NvbGlkJyxcbiAgICBsYWJlbDogJ2xlYWRzIHRvJ1xuICB9LFxuICBbRURHRV9UWVBFUy5FTkFCTEVTXToge1xuICAgIHN0cm9rZTogJyMxMGI5ODEnLFxuICAgIHN0cm9rZVdpZHRoOiAyLFxuICAgIHN0eWxlOiAnZGFzaGVkJyxcbiAgICBsYWJlbDogJ2VuYWJsZXMnXG4gIH0sXG4gIFtFREdFX1RZUEVTLlJFUVVJUkVTXToge1xuICAgIHN0cm9rZTogJyNlZjQ0NDQnLFxuICAgIHN0cm9rZVdpZHRoOiAyLFxuICAgIHN0eWxlOiAnZG90dGVkJyxcbiAgICBsYWJlbDogJ3JlcXVpcmVzJ1xuICB9LFxuICBbRURHRV9UWVBFUy5DT05UUklCVVRFU19UT106IHtcbiAgICBzdHJva2U6ICcjZjU5ZTBiJyxcbiAgICBzdHJva2VXaWR0aDogMixcbiAgICBzdHlsZTogJ3NvbGlkJyxcbiAgICBsYWJlbDogJ2NvbnRyaWJ1dGVzIHRvJ1xuICB9XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBib2FyZFxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQm9hcmQobmFtZSA9ICdUaGVvcnkgb2YgQ2hhbmdlIEJvYXJkJykge1xuICBjb25zdCBib2FyZElkID0gZ2VuZXJhdGVJZCgpO1xuICBcbiAgLy8gQ3JlYXRlIGxpc3RzIHdpdGggcHJvcGVyIElEcyBhbmQgZGVmYXVsdCBzZWN0aW9uc1xuICBjb25zdCBsaXN0cyA9IERFRkFVTFRfTElTVFMubWFwKGxpc3QgPT4ge1xuICAgIGNvbnN0IGRlZmF1bHRTZWN0aW9uID0gY3JlYXRlU2VjdGlvbignVW5ncm91cGVkJywgbGlzdC5pZCwgMCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmxpc3QsIFxuICAgICAgaWQ6IGxpc3QuaWQsIC8vIEtlZXAgdGhlIHByZWRlZmluZWQgSURzIGZvciBjb25zaXN0ZW5jeVxuICAgICAgbm9kZUlkczogW10sXG4gICAgICBzZWN0aW9uczogW2RlZmF1bHRTZWN0aW9uXVxuICAgIH07XG4gIH0pO1xuXG4gIC8vIENyZWF0ZSBzYW1wbGUgbm9kZXNcbiAgY29uc3Qgc2FtcGxlTm9kZXMgPSBbXG4gICAgLy8gQWN0aXZpdGllc1xuICAgIGNyZWF0ZU5vZGUoJ0NvbW11bml0eSBUcmFpbmluZyBXb3Jrc2hvcHMnLCAnYWN0aXZpdGllcycsIE5PREVfVFlQRVMuQUNUSVZJVFkpLFxuICAgIGNyZWF0ZU5vZGUoJ1RlYWNoZXIgUHJvZmVzc2lvbmFsIERldmVsb3BtZW50JywgJ2FjdGl2aXRpZXMnLCBOT0RFX1RZUEVTLkFDVElWSVRZKSxcbiAgICBjcmVhdGVOb2RlKCdEaWdpdGFsIExlYXJuaW5nIFBsYXRmb3JtIERldmVsb3BtZW50JywgJ2FjdGl2aXRpZXMnLCBOT0RFX1RZUEVTLkFDVElWSVRZKSxcbiAgICBjcmVhdGVOb2RlKCdDdXJyaWN1bHVtIERlc2lnbiBhbmQgUmV2aWV3JywgJ2FjdGl2aXRpZXMnLCBOT0RFX1RZUEVTLkFDVElWSVRZKSxcbiAgICBcbiAgICAvLyBPdXRwdXRzXG4gICAgY3JlYXRlTm9kZSgnNTAwIFRlYWNoZXJzIFRyYWluZWQnLCAnb3V0cHV0cycsIE5PREVfVFlQRVMuT1VUUFVUKSxcbiAgICBjcmVhdGVOb2RlKCdPbmxpbmUgTGVhcm5pbmcgUGxhdGZvcm0gTGF1bmNoZWQnLCAnb3V0cHV0cycsIE5PREVfVFlQRVMuT1VUUFVUKSxcbiAgICBjcmVhdGVOb2RlKCdVcGRhdGVkIEN1cnJpY3VsdW0gTWF0ZXJpYWxzJywgJ291dHB1dHMnLCBOT0RFX1RZUEVTLk9VVFBVVCksXG4gICAgY3JlYXRlTm9kZSgnQ29tbXVuaXR5IExlYXJuaW5nIENlbnRlcnMgRXN0YWJsaXNoZWQnLCAnb3V0cHV0cycsIE5PREVfVFlQRVMuT1VUUFVUKSxcbiAgICBcbiAgICAvLyBJbnRlcm1lZGlhdGUgT3V0Y29tZXNcbiAgICBjcmVhdGVOb2RlKCdJbXByb3ZlZCBUZWFjaGluZyBRdWFsaXR5JywgJ2ludGVybWVkaWF0ZS0xJywgTk9ERV9UWVBFUy5JTlRFUk1FRElBVEVfT1VUQ09NRSksXG4gICAgY3JlYXRlTm9kZSgnSW5jcmVhc2VkIFN0dWRlbnQgRW5nYWdlbWVudCcsICdpbnRlcm1lZGlhdGUtMScsIE5PREVfVFlQRVMuSU5URVJNRURJQVRFX09VVENPTUUpLFxuICAgIGNyZWF0ZU5vZGUoJ0VuaGFuY2VkIERpZ2l0YWwgTGl0ZXJhY3knLCAnaW50ZXJtZWRpYXRlLTEnLCBOT0RFX1RZUEVTLklOVEVSTUVESUFURV9PVVRDT01FKSxcbiAgICBcbiAgICAvLyBGaW5hbCBPdXRjb21lc1xuICAgIGNyZWF0ZU5vZGUoJ0ltcHJvdmVkIFN0dWRlbnQgTGVhcm5pbmcgT3V0Y29tZXMnLCAnZmluYWwtb3V0Y29tZXMnLCBOT0RFX1RZUEVTLkZJTkFMX09VVENPTUUpLFxuICAgIGNyZWF0ZU5vZGUoJ1JlZHVjZWQgRWR1Y2F0aW9uYWwgSW5lcXVhbGl0eScsICdmaW5hbC1vdXRjb21lcycsIE5PREVfVFlQRVMuRklOQUxfT1VUQ09NRSksXG4gICAgY3JlYXRlTm9kZSgnSW5jcmVhc2VkIFNjaG9vbCBDb21wbGV0aW9uIFJhdGVzJywgJ2ZpbmFsLW91dGNvbWVzJywgTk9ERV9UWVBFUy5GSU5BTF9PVVRDT01FKSxcbiAgICBcbiAgICAvLyBJbXBhY3RcbiAgICBjcmVhdGVOb2RlKCdTdXN0YWluYWJsZSBDb21tdW5pdHkgRGV2ZWxvcG1lbnQnLCAnaW1wYWN0JywgTk9ERV9UWVBFUy5JTVBBQ1QpLFxuICAgIGNyZWF0ZU5vZGUoJ1JlZHVjZWQgUG92ZXJ0eSBpbiBUYXJnZXQgQ29tbXVuaXRpZXMnLCAnaW1wYWN0JywgTk9ERV9UWVBFUy5JTVBBQ1QpXG4gIF07XG5cbiAgLy8gU2V0IHByb3BlciBvcmRlciBmb3Igbm9kZXMgd2l0aGluIGVhY2ggbGlzdFxuICBzYW1wbGVOb2Rlcy5mb3JFYWNoKChub2RlLCBpbmRleCkgPT4ge1xuICAgIGNvbnN0IGxpc3ROb2RlcyA9IHNhbXBsZU5vZGVzLmZpbHRlcihuID0+IG4ubGlzdElkID09PSBub2RlLmxpc3RJZCk7XG4gICAgY29uc3Qgbm9kZUluZGV4SW5MaXN0ID0gbGlzdE5vZGVzLmZpbmRJbmRleChuID0+IG4uaWQgPT09IG5vZGUuaWQpO1xuICAgIG5vZGUub3JkZXIgPSBub2RlSW5kZXhJbkxpc3Q7XG4gICAgbm9kZS5kZXNjcmlwdGlvbiA9IGdldE5vZGVEZXNjcmlwdGlvbihub2RlLnRpdGxlLCBub2RlLnR5cGUpO1xuICB9KTtcblxuICAvLyBDcmVhdGUgc29tZSBzYW1wbGUgZWRnZXMgdG8gc2hvdyByZWxhdGlvbnNoaXBzXG4gIGNvbnN0IHNhbXBsZUVkZ2VzID0gW1xuICAgIGNyZWF0ZUVkZ2Uoc2FtcGxlTm9kZXNbMF0uaWQsIHNhbXBsZU5vZGVzWzRdLmlkLCBFREdFX1RZUEVTLkxFQURTX1RPKSwgLy8gVHJhaW5pbmcgLT4gVGVhY2hlcnMgVHJhaW5lZFxuICAgIGNyZWF0ZUVkZ2Uoc2FtcGxlTm9kZXNbMV0uaWQsIHNhbXBsZU5vZGVzWzRdLmlkLCBFREdFX1RZUEVTLkxFQURTX1RPKSwgLy8gUHJvZiBEZXYgLT4gVGVhY2hlcnMgVHJhaW5lZFxuICAgIGNyZWF0ZUVkZ2Uoc2FtcGxlTm9kZXNbMl0uaWQsIHNhbXBsZU5vZGVzWzVdLmlkLCBFREdFX1RZUEVTLkxFQURTX1RPKSwgLy8gUGxhdGZvcm0gRGV2IC0+IFBsYXRmb3JtIExhdW5jaGVkXG4gICAgY3JlYXRlRWRnZShzYW1wbGVOb2Rlc1s0XS5pZCwgc2FtcGxlTm9kZXNbOF0uaWQsIEVER0VfVFlQRVMuTEVBRFNfVE8pLCAvLyBUZWFjaGVycyBUcmFpbmVkIC0+IFRlYWNoaW5nIFF1YWxpdHlcbiAgICBjcmVhdGVFZGdlKHNhbXBsZU5vZGVzWzVdLmlkLCBzYW1wbGVOb2Rlc1sxMF0uaWQsIEVER0VfVFlQRVMuTEVBRFNfVE8pLCAvLyBQbGF0Zm9ybSAtPiBEaWdpdGFsIExpdGVyYWN5XG4gICAgY3JlYXRlRWRnZShzYW1wbGVOb2Rlc1s4XS5pZCwgc2FtcGxlTm9kZXNbMTFdLmlkLCBFREdFX1RZUEVTLkxFQURTX1RPKSwgLy8gVGVhY2hpbmcgUXVhbGl0eSAtPiBMZWFybmluZyBPdXRjb21lc1xuICAgIGNyZWF0ZUVkZ2Uoc2FtcGxlTm9kZXNbMTFdLmlkLCBzYW1wbGVOb2Rlc1sxNV0uaWQsIEVER0VfVFlQRVMuQ09OVFJJQlVURVNfVE8pLCAvLyBMZWFybmluZyAtPiBEZXZlbG9wbWVudFxuICBdO1xuXG4gIHJldHVybiB7XG4gICAgaWQ6IGJvYXJkSWQsXG4gICAgbmFtZSxcbiAgICBkZXNjcmlwdGlvbjogJ0Egc2FtcGxlIFRoZW9yeSBvZiBDaGFuZ2UgZm9yIGVkdWNhdGlvbiBpbXByb3ZlbWVudCcsXG4gICAgbGlzdHMsXG4gICAgbm9kZXM6IHNhbXBsZU5vZGVzLFxuICAgIGVkZ2VzOiBzYW1wbGVFZGdlcyxcbiAgICBzZXR0aW5nczoge1xuICAgICAgc2hvd0xhYmVsczogdHJ1ZSxcbiAgICAgIHNuYXBUb0dyaWQ6IGZhbHNlLFxuICAgICAgYXV0b0xheW91dDogdHJ1ZSxcbiAgICAgIHRoZW1lOiAnbGlnaHQnXG4gICAgfSxcbiAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICB9O1xufVxuXG4vKipcbiAqIEdldCBzYW1wbGUgZGVzY3JpcHRpb24gZm9yIGEgbm9kZSBiYXNlZCBvbiBpdHMgdHlwZVxuICovXG5mdW5jdGlvbiBnZXROb2RlRGVzY3JpcHRpb24odGl0bGUsIHR5cGUpIHtcbiAgY29uc3QgZGVzY3JpcHRpb25zID0ge1xuICAgIFtOT0RFX1RZUEVTLkFDVElWSVRZXTogJ0tleSBhY3Rpdml0eSB0byBpbXBsZW1lbnQgdGhlIHByb2dyYW0nLFxuICAgIFtOT0RFX1RZUEVTLk9VVFBVVF06ICdEaXJlY3QgcmVzdWx0IG9mIHByb2dyYW0gYWN0aXZpdGllcycsXG4gICAgW05PREVfVFlQRVMuSU5URVJNRURJQVRFX09VVENPTUVdOiAnTWVkaXVtLXRlcm0gY2hhbmdlIHJlc3VsdGluZyBmcm9tIG91dHB1dHMnLFxuICAgIFtOT0RFX1RZUEVTLkZJTkFMX09VVENPTUVdOiAnTG9uZy10ZXJtIGNoYW5nZSB3ZSBhaW0gdG8gYWNoaWV2ZScsXG4gICAgW05PREVfVFlQRVMuSU1QQUNUXTogJ1VsdGltYXRlIHNvY2lldGFsIGNoYW5nZSB3ZSBjb250cmlidXRlIHRvJ1xuICB9O1xuICByZXR1cm4gZGVzY3JpcHRpb25zW3R5cGVdIHx8ICdEZXNjcmlwdGlvbiBmb3IgdGhpcyBub2RlJztcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgc2VjdGlvbiB3aXRoaW4gYSBsaXN0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTZWN0aW9uKG5hbWUgPSAnVW5ncm91cGVkJywgbGlzdElkLCBvcmRlciA9IDApIHtcbiAgcmV0dXJuIHtcbiAgICBpZDogZ2VuZXJhdGVJZCgpLFxuICAgIG5hbWUsXG4gICAgbGlzdElkLFxuICAgIG9yZGVyLFxuICAgIGNvbGxhcHNlZDogZmFsc2UsXG4gICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgfTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgbGlzdFxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTGlzdChuYW1lLCBjb2xvciA9ICcjNmI3MjgwJywgb3JkZXIgPSAwLCB0eXBlID0gJ2ludGVybWVkaWF0ZScpIHtcbiAgY29uc3QgbGlzdElkID0gZ2VuZXJhdGVJZCgpO1xuICAvLyBDcmVhdGUgZGVmYXVsdCBcIlVuZ3JvdXBlZFwiIHNlY3Rpb24gZm9yIHRoZSBsaXN0XG4gIGNvbnN0IGRlZmF1bHRTZWN0aW9uID0gY3JlYXRlU2VjdGlvbignVW5ncm91cGVkJywgbGlzdElkLCAwKTtcbiAgXG4gIHJldHVybiB7XG4gICAgaWQ6IGxpc3RJZCxcbiAgICBuYW1lLFxuICAgIGNvbG9yLFxuICAgIG9yZGVyLFxuICAgIHR5cGUsXG4gICAgY29sbGFwc2VkOiBmYWxzZSxcbiAgICBub2RlSWRzOiBbXSxcbiAgICBzZWN0aW9uczogW2RlZmF1bHRTZWN0aW9uXVxuICB9O1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBub2RlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVOb2RlKHRpdGxlLCBsaXN0SWQsIHR5cGUgPSBOT0RFX1RZUEVTLkFDVElWSVRZLCBzZWN0aW9uSWQgPSBudWxsKSB7XG4gIHJldHVybiB7XG4gICAgaWQ6IGdlbmVyYXRlSWQoKSxcbiAgICB0aXRsZSxcbiAgICBkZXNjcmlwdGlvbjogJycsXG4gICAgbGlzdElkLFxuICAgIHNlY3Rpb25JZCwgLy8gbnVsbCBtZWFucyB1bmdyb3VwZWQgKHdpbGwgYmUgYXNzaWduZWQgdG8gZmlyc3Qgc2VjdGlvbilcbiAgICB0eXBlLFxuICAgIHRhZ3M6IFtdLFxuICAgIGNvbG9yOiAnJyxcbiAgICBwcmlvcml0eTogJ21lZGl1bScsXG4gICAgb3JkZXI6IDAsIC8vIEZvciBzb3J0aW5nIHdpdGhpbiBsaXN0L3NlY3Rpb25cbiAgICBwb3NpdGlvbjogeyB4OiAwLCB5OiAwIH0sIC8vIEZvciB2aXN1YWwgcG9zaXRpb25pbmdcbiAgICBzaXplOiB7IHdpZHRoOiAyMDAsIGhlaWdodDogMTAwIH0sXG4gICAgY29sbGFwc2VkOiBmYWxzZSxcbiAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICB9O1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBlZGdlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVFZGdlKHNvdXJjZUlkLCB0YXJnZXRJZCwgdHlwZSA9IEVER0VfVFlQRVMuTEVBRFNfVE8pIHtcbiAgcmV0dXJuIHtcbiAgICBpZDogZ2VuZXJhdGVJZCgpLFxuICAgIHNvdXJjZUlkLFxuICAgIHRhcmdldElkLFxuICAgIHR5cGUsXG4gICAgbGFiZWw6IEVER0VfU1RZTEVTW3R5cGVdLmxhYmVsLFxuICAgIHN0eWxlOiBFREdFX1NUWUxFU1t0eXBlXSxcbiAgICBhbmltYXRlZDogZmFsc2UsXG4gICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgfTtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBhIHVuaXF1ZSBJRFxuICovXG5mdW5jdGlvbiBnZW5lcmF0ZUlkKCkge1xuICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIDkpO1xufSJdLCJuYW1lcyI6WyJERUZBVUxUX0xJU1RTIiwiaWQiLCJuYW1lIiwiY29sb3IiLCJvcmRlciIsInR5cGUiLCJMSVNUX1RZUEVTIiwiRklYRUQiLCJJTlRFUk1FRElBVEUiLCJOT0RFX1RZUEVTIiwiQUNUSVZJVFkiLCJPVVRQVVQiLCJJTlRFUk1FRElBVEVfT1VUQ09NRSIsIkZJTkFMX09VVENPTUUiLCJJTVBBQ1QiLCJFREdFX1RZUEVTIiwiTEVBRFNfVE8iLCJFTkFCTEVTIiwiUkVRVUlSRVMiLCJDT05UUklCVVRFU19UTyIsIkVER0VfU1RZTEVTIiwic3Ryb2tlIiwic3Ryb2tlV2lkdGgiLCJzdHlsZSIsImxhYmVsIiwiY3JlYXRlQm9hcmQiLCJib2FyZElkIiwiZ2VuZXJhdGVJZCIsImxpc3RzIiwibWFwIiwibGlzdCIsImRlZmF1bHRTZWN0aW9uIiwiY3JlYXRlU2VjdGlvbiIsIm5vZGVJZHMiLCJzZWN0aW9ucyIsInNhbXBsZU5vZGVzIiwiY3JlYXRlTm9kZSIsImZvckVhY2giLCJub2RlIiwiaW5kZXgiLCJsaXN0Tm9kZXMiLCJmaWx0ZXIiLCJuIiwibGlzdElkIiwibm9kZUluZGV4SW5MaXN0IiwiZmluZEluZGV4IiwiZGVzY3JpcHRpb24iLCJnZXROb2RlRGVzY3JpcHRpb24iLCJ0aXRsZSIsInNhbXBsZUVkZ2VzIiwiY3JlYXRlRWRnZSIsIm5vZGVzIiwiZWRnZXMiLCJzZXR0aW5ncyIsInNob3dMYWJlbHMiLCJzbmFwVG9HcmlkIiwiYXV0b0xheW91dCIsInRoZW1lIiwiY3JlYXRlZEF0IiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwidXBkYXRlZEF0IiwiZGVzY3JpcHRpb25zIiwiY29sbGFwc2VkIiwiY3JlYXRlTGlzdCIsInNlY3Rpb25JZCIsInRhZ3MiLCJwcmlvcml0eSIsInBvc2l0aW9uIiwieCIsInkiLCJzaXplIiwid2lkdGgiLCJoZWlnaHQiLCJzb3VyY2VJZCIsInRhcmdldElkIiwiYW5pbWF0ZWQiLCJNYXRoIiwicmFuZG9tIiwidG9TdHJpbmciLCJzdWJzdHIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/utils/tocModels.js\n"));

/***/ })

});