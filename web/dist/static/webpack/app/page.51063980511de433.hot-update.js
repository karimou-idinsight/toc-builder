"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/app/utils/tocModels.js":
/*!************************************!*\
  !*** ./src/app/utils/tocModels.js ***!
  \************************************/
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_LISTS: function() { return /* binding */ DEFAULT_LISTS; },\n/* harmony export */   EDGE_STYLES: function() { return /* binding */ EDGE_STYLES; },\n/* harmony export */   EDGE_TYPES: function() { return /* binding */ EDGE_TYPES; },\n/* harmony export */   LIST_TYPES: function() { return /* binding */ LIST_TYPES; },\n/* harmony export */   NODE_TYPES: function() { return /* binding */ NODE_TYPES; },\n/* harmony export */   createBoard: function() { return /* binding */ createBoard; },\n/* harmony export */   createEdge: function() { return /* binding */ createEdge; },\n/* harmony export */   createList: function() { return /* binding */ createList; },\n/* harmony export */   createNode: function() { return /* binding */ createNode; },\n/* harmony export */   createSection: function() { return /* binding */ createSection; }\n/* harmony export */ });\n/**\n * Theory of Change data models and types\n */ // Default list types for Theory of Change\nconst DEFAULT_LISTS = [\n    {\n        id: \"activities\",\n        name: \"Activities\",\n        color: \"#3b82f6\",\n        order: 0,\n        type: \"fixed\"\n    },\n    {\n        id: \"outputs\",\n        name: \"Outputs\",\n        color: \"#10b981\",\n        order: 1,\n        type: \"fixed\"\n    },\n    {\n        id: \"intermediate-1\",\n        name: \"Intermediate Outcomes 1\",\n        color: \"#f59e0b\",\n        order: 2,\n        type: \"intermediate\"\n    },\n    {\n        id: \"final-outcomes\",\n        name: \"Final Outcomes\",\n        color: \"#ef4444\",\n        order: 3,\n        type: \"fixed\"\n    },\n    {\n        id: \"impact\",\n        name: \"Impact\",\n        color: \"#8b5cf6\",\n        order: 4,\n        type: \"fixed\"\n    }\n];\n// List types\nconst LIST_TYPES = {\n    FIXED: \"fixed\",\n    INTERMEDIATE: \"intermediate\"\n};\n// Node types\nconst NODE_TYPES = {\n    ACTIVITY: \"activity\",\n    OUTPUT: \"output\",\n    INTERMEDIATE_OUTCOME: \"intermediate_outcome\",\n    FINAL_OUTCOME: \"final_outcome\",\n    IMPACT: \"impact\"\n};\n// Edge types\nconst EDGE_TYPES = {\n    LEADS_TO: \"leads_to\",\n    ENABLES: \"enables\",\n    REQUIRES: \"requires\",\n    CONTRIBUTES_TO: \"contributes_to\"\n};\n// Default edge styles\nconst EDGE_STYLES = {\n    [EDGE_TYPES.LEADS_TO]: {\n        stroke: \"#1355bfff\",\n        strokeWidth: 2,\n        style: \"solid\",\n        label: \"leads to\"\n    },\n    [EDGE_TYPES.ENABLES]: {\n        stroke: \"#10b981\",\n        strokeWidth: 2,\n        style: \"dashed\",\n        label: \"enables\"\n    },\n    [EDGE_TYPES.REQUIRES]: {\n        stroke: \"#ef4444\",\n        strokeWidth: 2,\n        style: \"dotted\",\n        label: \"requires\"\n    },\n    [EDGE_TYPES.CONTRIBUTES_TO]: {\n        stroke: \"#f59e0b\",\n        strokeWidth: 2,\n        style: \"solid\",\n        label: \"contributes to\"\n    }\n};\n/**\n * Create a new board\n */ function createBoard() {\n    let name = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \"Theory of Change Board\";\n    const boardId = generateId();\n    // Create lists with proper IDs and default sections\n    const lists = DEFAULT_LISTS.map((list)=>{\n        const defaultSection = createSection(\"Ungrouped\", list.id, 0);\n        return {\n            ...list,\n            id: list.id,\n            nodeIds: [],\n            sections: [\n                defaultSection\n            ]\n        };\n    });\n    // Create sample nodes\n    const sampleNodes = [\n        // Activities\n        createNode(\"Community Training Workshops\", \"activities\", NODE_TYPES.ACTIVITY),\n        createNode(\"Teacher Professional Development\", \"activities\", NODE_TYPES.ACTIVITY),\n        createNode(\"Digital Learning Platform Development\", \"activities\", NODE_TYPES.ACTIVITY),\n        createNode(\"Curriculum Design and Review\", \"activities\", NODE_TYPES.ACTIVITY),\n        // Outputs\n        createNode(\"500 Teachers Trained\", \"outputs\", NODE_TYPES.OUTPUT),\n        createNode(\"Online Learning Platform Launched\", \"outputs\", NODE_TYPES.OUTPUT),\n        createNode(\"Updated Curriculum Materials\", \"outputs\", NODE_TYPES.OUTPUT),\n        createNode(\"Community Learning Centers Established\", \"outputs\", NODE_TYPES.OUTPUT),\n        // Intermediate Outcomes\n        createNode(\"Improved Teaching Quality\", \"intermediate-1\", NODE_TYPES.INTERMEDIATE_OUTCOME),\n        createNode(\"Increased Student Engagement\", \"intermediate-1\", NODE_TYPES.INTERMEDIATE_OUTCOME),\n        createNode(\"Enhanced Digital Literacy\", \"intermediate-1\", NODE_TYPES.INTERMEDIATE_OUTCOME),\n        // Final Outcomes\n        createNode(\"Improved Student Learning Outcomes\", \"final-outcomes\", NODE_TYPES.FINAL_OUTCOME),\n        createNode(\"Reduced Educational Inequality\", \"final-outcomes\", NODE_TYPES.FINAL_OUTCOME),\n        createNode(\"Increased School Completion Rates\", \"final-outcomes\", NODE_TYPES.FINAL_OUTCOME),\n        // Impact\n        createNode(\"Sustainable Community Development\", \"impact\", NODE_TYPES.IMPACT),\n        createNode(\"Reduced Poverty in Target Communities\", \"impact\", NODE_TYPES.IMPACT)\n    ];\n    // Set proper order for nodes within each list and assign to default section\n    sampleNodes.forEach((node, index)=>{\n        const listNodes = sampleNodes.filter((n)=>n.listId === node.listId);\n        const nodeIndexInList = listNodes.findIndex((n)=>n.id === node.id);\n        node.order = nodeIndexInList;\n        node.description = getNodeDescription(node.title, node.type);\n        // Assign node to the list's first (ungrouped) section\n        const list = lists.find((l)=>l.id === node.listId);\n        if (list && list.sections && list.sections.length > 0) {\n            node.sectionId = list.sections[0].id;\n        }\n    });\n    // Create some sample edges to show relationships\n    const sampleEdges = [\n        createEdge(sampleNodes[0].id, sampleNodes[4].id, EDGE_TYPES.LEADS_TO),\n        createEdge(sampleNodes[1].id, sampleNodes[4].id, EDGE_TYPES.LEADS_TO),\n        createEdge(sampleNodes[2].id, sampleNodes[5].id, EDGE_TYPES.LEADS_TO),\n        createEdge(sampleNodes[4].id, sampleNodes[8].id, EDGE_TYPES.LEADS_TO),\n        createEdge(sampleNodes[5].id, sampleNodes[10].id, EDGE_TYPES.LEADS_TO),\n        createEdge(sampleNodes[8].id, sampleNodes[11].id, EDGE_TYPES.LEADS_TO),\n        createEdge(sampleNodes[11].id, sampleNodes[15].id, EDGE_TYPES.CONTRIBUTES_TO)\n    ];\n    return {\n        id: boardId,\n        name,\n        description: \"A sample Theory of Change for education improvement\",\n        lists,\n        nodes: sampleNodes,\n        edges: sampleEdges,\n        settings: {\n            showLabels: true,\n            snapToGrid: false,\n            autoLayout: true,\n            theme: \"light\"\n        },\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString()\n    };\n}\n/**\n * Get sample description for a node based on its type\n */ function getNodeDescription(title, type) {\n    const descriptions = {\n        [NODE_TYPES.ACTIVITY]: \"Key activity to implement the program\",\n        [NODE_TYPES.OUTPUT]: \"Direct result of program activities\",\n        [NODE_TYPES.INTERMEDIATE_OUTCOME]: \"Medium-term change resulting from outputs\",\n        [NODE_TYPES.FINAL_OUTCOME]: \"Long-term change we aim to achieve\",\n        [NODE_TYPES.IMPACT]: \"Ultimate societal change we contribute to\"\n    };\n    return descriptions[type] || \"Description for this node\";\n}\n/**\n * Create a new section within a list\n */ function createSection() {\n    let name = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \"Ungrouped\", listId = arguments.length > 1 ? arguments[1] : void 0, order = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;\n    return {\n        id: generateId(),\n        name,\n        listId,\n        order,\n        collapsed: false,\n        createdAt: new Date().toISOString()\n    };\n}\n/**\n * Create a new list\n */ function createList(name) {\n    let color = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"#6b7280\", order = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, type = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : \"intermediate\";\n    const listId = generateId();\n    // Create default \"Ungrouped\" section for the list\n    const defaultSection = createSection(\"Ungrouped\", listId, 0);\n    return {\n        id: listId,\n        name,\n        color,\n        order,\n        type,\n        collapsed: false,\n        nodeIds: [],\n        sections: [\n            defaultSection\n        ]\n    };\n}\n/**\n * Create a new node\n */ function createNode(title, listId) {\n    let type = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : NODE_TYPES.ACTIVITY, sectionId = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;\n    return {\n        id: generateId(),\n        title,\n        description: \"\",\n        listId,\n        sectionId,\n        type,\n        tags: [],\n        color: \"\",\n        priority: \"medium\",\n        order: 0,\n        position: {\n            x: 0,\n            y: 0\n        },\n        size: {\n            width: 200,\n            height: 100\n        },\n        collapsed: false,\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString()\n    };\n}\n/**\n * Create a new edge\n */ function createEdge(sourceId, targetId) {\n    let type = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : EDGE_TYPES.LEADS_TO;\n    return {\n        id: generateId(),\n        sourceId,\n        targetId,\n        type,\n        label: EDGE_STYLES[type].label,\n        style: EDGE_STYLES[type],\n        animated: false,\n        createdAt: new Date().toISOString()\n    };\n}\n/**\n * Generate a unique ID\n */ function generateId() {\n    return Math.random().toString(36).substr(2, 9);\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = __webpack_module__.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = __webpack_module__.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, __webpack_module__.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                __webpack_module__.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                __webpack_module__.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        __webpack_module__.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    __webpack_module__.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvdXRpbHMvdG9jTW9kZWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Q0FFQyxHQUVELDBDQUEwQztBQUNuQyxNQUFNQSxnQkFBZ0I7SUFDM0I7UUFBRUMsSUFBSTtRQUFjQyxNQUFNO1FBQWNDLE9BQU87UUFBV0MsT0FBTztRQUFHQyxNQUFNO0lBQVE7SUFDbEY7UUFBRUosSUFBSTtRQUFXQyxNQUFNO1FBQVdDLE9BQU87UUFBV0MsT0FBTztRQUFHQyxNQUFNO0lBQVE7SUFDNUU7UUFBRUosSUFBSTtRQUFrQkMsTUFBTTtRQUEyQkMsT0FBTztRQUFXQyxPQUFPO1FBQUdDLE1BQU07SUFBZTtJQUMxRztRQUFFSixJQUFJO1FBQWtCQyxNQUFNO1FBQWtCQyxPQUFPO1FBQVdDLE9BQU87UUFBR0MsTUFBTTtJQUFRO0lBQzFGO1FBQUVKLElBQUk7UUFBVUMsTUFBTTtRQUFVQyxPQUFPO1FBQVdDLE9BQU87UUFBR0MsTUFBTTtJQUFRO0NBQzNFLENBQUM7QUFFRixhQUFhO0FBQ04sTUFBTUMsYUFBYTtJQUN4QkMsT0FBTztJQUNQQyxjQUFjO0FBQ2hCLEVBQUU7QUFFRixhQUFhO0FBQ04sTUFBTUMsYUFBYTtJQUN4QkMsVUFBVTtJQUNWQyxRQUFRO0lBQ1JDLHNCQUFzQjtJQUN0QkMsZUFBZTtJQUNmQyxRQUFRO0FBQ1YsRUFBRTtBQUVGLGFBQWE7QUFDTixNQUFNQyxhQUFhO0lBQ3hCQyxVQUFVO0lBQ1ZDLFNBQVM7SUFDVEMsVUFBVTtJQUNWQyxnQkFBZ0I7QUFDbEIsRUFBRTtBQUVGLHNCQUFzQjtBQUNmLE1BQU1DLGNBQWM7SUFDekIsQ0FBQ0wsV0FBV0MsUUFBUSxDQUFDLEVBQUU7UUFDckJLLFFBQVE7UUFDUkMsYUFBYTtRQUNiQyxPQUFPO1FBQ1BDLE9BQU87SUFDVDtJQUNBLENBQUNULFdBQVdFLE9BQU8sQ0FBQyxFQUFFO1FBQ3BCSSxRQUFRO1FBQ1JDLGFBQWE7UUFDYkMsT0FBTztR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TCxXQUFXLElBQUlDLE9BQU9DLFdBQVc7UUFDakNDLFdBQVcsSUFBSUYsT0FBT0MsV0FBVztJQUNuQztBQUNGO0FBRUE7O0NBRUMsR0FDTSxTQUFTVixXQUFXdUIsUUFBUSxFQUFFQyxRQUFRO1FBQUV6RSxPQUFBQSxpRUFBT1UsV0FBV0MsUUFBUTtJQUN2RSxPQUFPO1FBQ0xmLElBQUkwQjtRQUNKa0Q7UUFDQUM7UUFDQXpFO1FBQ0FtQixPQUFPSixXQUFXLENBQUNmLEtBQUssQ0FBQ21CLEtBQUs7UUFDOUJELE9BQU9ILFdBQVcsQ0FBQ2YsS0FBSztRQUN4QjBFLFVBQVU7UUFDVmpCLFdBQVcsSUFBSUMsT0FBT0MsV0FBVztJQUNuQztBQUNGO0FBRUE7O0NBRUMsR0FDRCxTQUFTckM7SUFDUCxPQUFPcUQsS0FBS0MsTUFBTSxHQUFHQyxRQUFRLENBQUMsSUFBSUMsTUFBTSxDQUFDLEdBQUc7QUFDOUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2FwcC91dGlscy90b2NNb2RlbHMuanM/NWJhOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFRoZW9yeSBvZiBDaGFuZ2UgZGF0YSBtb2RlbHMgYW5kIHR5cGVzXG4gKi9cblxuLy8gRGVmYXVsdCBsaXN0IHR5cGVzIGZvciBUaGVvcnkgb2YgQ2hhbmdlXG5leHBvcnQgY29uc3QgREVGQVVMVF9MSVNUUyA9IFtcbiAgeyBpZDogJ2FjdGl2aXRpZXMnLCBuYW1lOiAnQWN0aXZpdGllcycsIGNvbG9yOiAnIzNiODJmNicsIG9yZGVyOiAwLCB0eXBlOiAnZml4ZWQnIH0sXG4gIHsgaWQ6ICdvdXRwdXRzJywgbmFtZTogJ091dHB1dHMnLCBjb2xvcjogJyMxMGI5ODEnLCBvcmRlcjogMSwgdHlwZTogJ2ZpeGVkJyB9LFxuICB7IGlkOiAnaW50ZXJtZWRpYXRlLTEnLCBuYW1lOiAnSW50ZXJtZWRpYXRlIE91dGNvbWVzIDEnLCBjb2xvcjogJyNmNTllMGInLCBvcmRlcjogMiwgdHlwZTogJ2ludGVybWVkaWF0ZScgfSxcbiAgeyBpZDogJ2ZpbmFsLW91dGNvbWVzJywgbmFtZTogJ0ZpbmFsIE91dGNvbWVzJywgY29sb3I6ICcjZWY0NDQ0Jywgb3JkZXI6IDMsIHR5cGU6ICdmaXhlZCcgfSxcbiAgeyBpZDogJ2ltcGFjdCcsIG5hbWU6ICdJbXBhY3QnLCBjb2xvcjogJyM4YjVjZjYnLCBvcmRlcjogNCwgdHlwZTogJ2ZpeGVkJyB9XG5dO1xuXG4vLyBMaXN0IHR5cGVzXG5leHBvcnQgY29uc3QgTElTVF9UWVBFUyA9IHtcbiAgRklYRUQ6ICdmaXhlZCcsXG4gIElOVEVSTUVESUFURTogJ2ludGVybWVkaWF0ZSdcbn07XG5cbi8vIE5vZGUgdHlwZXNcbmV4cG9ydCBjb25zdCBOT0RFX1RZUEVTID0ge1xuICBBQ1RJVklUWTogJ2FjdGl2aXR5JyxcbiAgT1VUUFVUOiAnb3V0cHV0JyxcbiAgSU5URVJNRURJQVRFX09VVENPTUU6ICdpbnRlcm1lZGlhdGVfb3V0Y29tZScsXG4gIEZJTkFMX09VVENPTUU6ICdmaW5hbF9vdXRjb21lJyxcbiAgSU1QQUNUOiAnaW1wYWN0J1xufTtcblxuLy8gRWRnZSB0eXBlc1xuZXhwb3J0IGNvbnN0IEVER0VfVFlQRVMgPSB7XG4gIExFQURTX1RPOiAnbGVhZHNfdG8nLFxuICBFTkFCTEVTOiAnZW5hYmxlcycsXG4gIFJFUVVJUkVTOiAncmVxdWlyZXMnLFxuICBDT05UUklCVVRFU19UTzogJ2NvbnRyaWJ1dGVzX3RvJ1xufTtcblxuLy8gRGVmYXVsdCBlZGdlIHN0eWxlc1xuZXhwb3J0IGNvbnN0IEVER0VfU1RZTEVTID0ge1xuICBbRURHRV9UWVBFUy5MRUFEU19UT106IHtcbiAgICBzdHJva2U6ICcjMTM1NWJmZmYnLFxuICAgIHN0cm9rZVdpZHRoOiAyLFxuICAgIHN0eWxlOiAnc29saWQnLFxuICAgIGxhYmVsOiAnbGVhZHMgdG8nXG4gIH0sXG4gIFtFREdFX1RZUEVTLkVOQUJMRVNdOiB7XG4gICAgc3Ryb2tlOiAnIzEwYjk4MScsXG4gICAgc3Ryb2tlV2lkdGg6IDIsXG4gICAgc3R5bGU6ICdkYXNoZWQnLFxuICAgIGxhYmVsOiAnZW5hYmxlcydcbiAgfSxcbiAgW0VER0VfVFlQRVMuUkVRVUlSRVNdOiB7XG4gICAgc3Ryb2tlOiAnI2VmNDQ0NCcsXG4gICAgc3Ryb2tlV2lkdGg6IDIsXG4gICAgc3R5bGU6ICdkb3R0ZWQnLFxuICAgIGxhYmVsOiAncmVxdWlyZXMnXG4gIH0sXG4gIFtFREdFX1RZUEVTLkNPTlRSSUJVVEVTX1RPXToge1xuICAgIHN0cm9rZTogJyNmNTllMGInLFxuICAgIHN0cm9rZVdpZHRoOiAyLFxuICAgIHN0eWxlOiAnc29saWQnLFxuICAgIGxhYmVsOiAnY29udHJpYnV0ZXMgdG8nXG4gIH1cbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGJvYXJkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVCb2FyZChuYW1lID0gJ1RoZW9yeSBvZiBDaGFuZ2UgQm9hcmQnKSB7XG4gIGNvbnN0IGJvYXJkSWQgPSBnZW5lcmF0ZUlkKCk7XG4gIFxuICAvLyBDcmVhdGUgbGlzdHMgd2l0aCBwcm9wZXIgSURzIGFuZCBkZWZhdWx0IHNlY3Rpb25zXG4gIGNvbnN0IGxpc3RzID0gREVGQVVMVF9MSVNUUy5tYXAobGlzdCA9PiB7XG4gICAgY29uc3QgZGVmYXVsdFNlY3Rpb24gPSBjcmVhdGVTZWN0aW9uKCdVbmdyb3VwZWQnLCBsaXN0LmlkLCAwKTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4ubGlzdCwgXG4gICAgICBpZDogbGlzdC5pZCwgLy8gS2VlcCB0aGUgcHJlZGVmaW5lZCBJRHMgZm9yIGNvbnNpc3RlbmN5XG4gICAgICBub2RlSWRzOiBbXSxcbiAgICAgIHNlY3Rpb25zOiBbZGVmYXVsdFNlY3Rpb25dXG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gQ3JlYXRlIHNhbXBsZSBub2Rlc1xuICBjb25zdCBzYW1wbGVOb2RlcyA9IFtcbiAgICAvLyBBY3Rpdml0aWVzXG4gICAgY3JlYXRlTm9kZSgnQ29tbXVuaXR5IFRyYWluaW5nIFdvcmtzaG9wcycsICdhY3Rpdml0aWVzJywgTk9ERV9UWVBFUy5BQ1RJVklUWSksXG4gICAgY3JlYXRlTm9kZSgnVGVhY2hlciBQcm9mZXNzaW9uYWwgRGV2ZWxvcG1lbnQnLCAnYWN0aXZpdGllcycsIE5PREVfVFlQRVMuQUNUSVZJVFkpLFxuICAgIGNyZWF0ZU5vZGUoJ0RpZ2l0YWwgTGVhcm5pbmcgUGxhdGZvcm0gRGV2ZWxvcG1lbnQnLCAnYWN0aXZpdGllcycsIE5PREVfVFlQRVMuQUNUSVZJVFkpLFxuICAgIGNyZWF0ZU5vZGUoJ0N1cnJpY3VsdW0gRGVzaWduIGFuZCBSZXZpZXcnLCAnYWN0aXZpdGllcycsIE5PREVfVFlQRVMuQUNUSVZJVFkpLFxuICAgIFxuICAgIC8vIE91dHB1dHNcbiAgICBjcmVhdGVOb2RlKCc1MDAgVGVhY2hlcnMgVHJhaW5lZCcsICdvdXRwdXRzJywgTk9ERV9UWVBFUy5PVVRQVVQpLFxuICAgIGNyZWF0ZU5vZGUoJ09ubGluZSBMZWFybmluZyBQbGF0Zm9ybSBMYXVuY2hlZCcsICdvdXRwdXRzJywgTk9ERV9UWVBFUy5PVVRQVVQpLFxuICAgIGNyZWF0ZU5vZGUoJ1VwZGF0ZWQgQ3VycmljdWx1bSBNYXRlcmlhbHMnLCAnb3V0cHV0cycsIE5PREVfVFlQRVMuT1VUUFVUKSxcbiAgICBjcmVhdGVOb2RlKCdDb21tdW5pdHkgTGVhcm5pbmcgQ2VudGVycyBFc3RhYmxpc2hlZCcsICdvdXRwdXRzJywgTk9ERV9UWVBFUy5PVVRQVVQpLFxuICAgIFxuICAgIC8vIEludGVybWVkaWF0ZSBPdXRjb21lc1xuICAgIGNyZWF0ZU5vZGUoJ0ltcHJvdmVkIFRlYWNoaW5nIFF1YWxpdHknLCAnaW50ZXJtZWRpYXRlLTEnLCBOT0RFX1RZUEVTLklOVEVSTUVESUFURV9PVVRDT01FKSxcbiAgICBjcmVhdGVOb2RlKCdJbmNyZWFzZWQgU3R1ZGVudCBFbmdhZ2VtZW50JywgJ2ludGVybWVkaWF0ZS0xJywgTk9ERV9UWVBFUy5JTlRFUk1FRElBVEVfT1VUQ09NRSksXG4gICAgY3JlYXRlTm9kZSgnRW5oYW5jZWQgRGlnaXRhbCBMaXRlcmFjeScsICdpbnRlcm1lZGlhdGUtMScsIE5PREVfVFlQRVMuSU5URVJNRURJQVRFX09VVENPTUUpLFxuICAgIFxuICAgIC8vIEZpbmFsIE91dGNvbWVzXG4gICAgY3JlYXRlTm9kZSgnSW1wcm92ZWQgU3R1ZGVudCBMZWFybmluZyBPdXRjb21lcycsICdmaW5hbC1vdXRjb21lcycsIE5PREVfVFlQRVMuRklOQUxfT1VUQ09NRSksXG4gICAgY3JlYXRlTm9kZSgnUmVkdWNlZCBFZHVjYXRpb25hbCBJbmVxdWFsaXR5JywgJ2ZpbmFsLW91dGNvbWVzJywgTk9ERV9UWVBFUy5GSU5BTF9PVVRDT01FKSxcbiAgICBjcmVhdGVOb2RlKCdJbmNyZWFzZWQgU2Nob29sIENvbXBsZXRpb24gUmF0ZXMnLCAnZmluYWwtb3V0Y29tZXMnLCBOT0RFX1RZUEVTLkZJTkFMX09VVENPTUUpLFxuICAgIFxuICAgIC8vIEltcGFjdFxuICAgIGNyZWF0ZU5vZGUoJ1N1c3RhaW5hYmxlIENvbW11bml0eSBEZXZlbG9wbWVudCcsICdpbXBhY3QnLCBOT0RFX1RZUEVTLklNUEFDVCksXG4gICAgY3JlYXRlTm9kZSgnUmVkdWNlZCBQb3ZlcnR5IGluIFRhcmdldCBDb21tdW5pdGllcycsICdpbXBhY3QnLCBOT0RFX1RZUEVTLklNUEFDVClcbiAgXTtcblxuICAvLyBTZXQgcHJvcGVyIG9yZGVyIGZvciBub2RlcyB3aXRoaW4gZWFjaCBsaXN0IGFuZCBhc3NpZ24gdG8gZGVmYXVsdCBzZWN0aW9uXG4gIHNhbXBsZU5vZGVzLmZvckVhY2goKG5vZGUsIGluZGV4KSA9PiB7XG4gICAgY29uc3QgbGlzdE5vZGVzID0gc2FtcGxlTm9kZXMuZmlsdGVyKG4gPT4gbi5saXN0SWQgPT09IG5vZGUubGlzdElkKTtcbiAgICBjb25zdCBub2RlSW5kZXhJbkxpc3QgPSBsaXN0Tm9kZXMuZmluZEluZGV4KG4gPT4gbi5pZCA9PT0gbm9kZS5pZCk7XG4gICAgbm9kZS5vcmRlciA9IG5vZGVJbmRleEluTGlzdDtcbiAgICBub2RlLmRlc2NyaXB0aW9uID0gZ2V0Tm9kZURlc2NyaXB0aW9uKG5vZGUudGl0bGUsIG5vZGUudHlwZSk7XG4gICAgXG4gICAgLy8gQXNzaWduIG5vZGUgdG8gdGhlIGxpc3QncyBmaXJzdCAodW5ncm91cGVkKSBzZWN0aW9uXG4gICAgY29uc3QgbGlzdCA9IGxpc3RzLmZpbmQobCA9PiBsLmlkID09PSBub2RlLmxpc3RJZCk7XG4gICAgaWYgKGxpc3QgJiYgbGlzdC5zZWN0aW9ucyAmJiBsaXN0LnNlY3Rpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgIG5vZGUuc2VjdGlvbklkID0gbGlzdC5zZWN0aW9uc1swXS5pZDtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIENyZWF0ZSBzb21lIHNhbXBsZSBlZGdlcyB0byBzaG93IHJlbGF0aW9uc2hpcHNcbiAgY29uc3Qgc2FtcGxlRWRnZXMgPSBbXG4gICAgY3JlYXRlRWRnZShzYW1wbGVOb2Rlc1swXS5pZCwgc2FtcGxlTm9kZXNbNF0uaWQsIEVER0VfVFlQRVMuTEVBRFNfVE8pLCAvLyBUcmFpbmluZyAtPiBUZWFjaGVycyBUcmFpbmVkXG4gICAgY3JlYXRlRWRnZShzYW1wbGVOb2Rlc1sxXS5pZCwgc2FtcGxlTm9kZXNbNF0uaWQsIEVER0VfVFlQRVMuTEVBRFNfVE8pLCAvLyBQcm9mIERldiAtPiBUZWFjaGVycyBUcmFpbmVkXG4gICAgY3JlYXRlRWRnZShzYW1wbGVOb2Rlc1syXS5pZCwgc2FtcGxlTm9kZXNbNV0uaWQsIEVER0VfVFlQRVMuTEVBRFNfVE8pLCAvLyBQbGF0Zm9ybSBEZXYgLT4gUGxhdGZvcm0gTGF1bmNoZWRcbiAgICBjcmVhdGVFZGdlKHNhbXBsZU5vZGVzWzRdLmlkLCBzYW1wbGVOb2Rlc1s4XS5pZCwgRURHRV9UWVBFUy5MRUFEU19UTyksIC8vIFRlYWNoZXJzIFRyYWluZWQgLT4gVGVhY2hpbmcgUXVhbGl0eVxuICAgIGNyZWF0ZUVkZ2Uoc2FtcGxlTm9kZXNbNV0uaWQsIHNhbXBsZU5vZGVzWzEwXS5pZCwgRURHRV9UWVBFUy5MRUFEU19UTyksIC8vIFBsYXRmb3JtIC0+IERpZ2l0YWwgTGl0ZXJhY3lcbiAgICBjcmVhdGVFZGdlKHNhbXBsZU5vZGVzWzhdLmlkLCBzYW1wbGVOb2Rlc1sxMV0uaWQsIEVER0VfVFlQRVMuTEVBRFNfVE8pLCAvLyBUZWFjaGluZyBRdWFsaXR5IC0+IExlYXJuaW5nIE91dGNvbWVzXG4gICAgY3JlYXRlRWRnZShzYW1wbGVOb2Rlc1sxMV0uaWQsIHNhbXBsZU5vZGVzWzE1XS5pZCwgRURHRV9UWVBFUy5DT05UUklCVVRFU19UTyksIC8vIExlYXJuaW5nIC0+IERldmVsb3BtZW50XG4gIF07XG5cbiAgcmV0dXJuIHtcbiAgICBpZDogYm9hcmRJZCxcbiAgICBuYW1lLFxuICAgIGRlc2NyaXB0aW9uOiAnQSBzYW1wbGUgVGhlb3J5IG9mIENoYW5nZSBmb3IgZWR1Y2F0aW9uIGltcHJvdmVtZW50JyxcbiAgICBsaXN0cyxcbiAgICBub2Rlczogc2FtcGxlTm9kZXMsXG4gICAgZWRnZXM6IHNhbXBsZUVkZ2VzLFxuICAgIHNldHRpbmdzOiB7XG4gICAgICBzaG93TGFiZWxzOiB0cnVlLFxuICAgICAgc25hcFRvR3JpZDogZmFsc2UsXG4gICAgICBhdXRvTGF5b3V0OiB0cnVlLFxuICAgICAgdGhlbWU6ICdsaWdodCdcbiAgICB9LFxuICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gIH07XG59XG5cbi8qKlxuICogR2V0IHNhbXBsZSBkZXNjcmlwdGlvbiBmb3IgYSBub2RlIGJhc2VkIG9uIGl0cyB0eXBlXG4gKi9cbmZ1bmN0aW9uIGdldE5vZGVEZXNjcmlwdGlvbih0aXRsZSwgdHlwZSkge1xuICBjb25zdCBkZXNjcmlwdGlvbnMgPSB7XG4gICAgW05PREVfVFlQRVMuQUNUSVZJVFldOiAnS2V5IGFjdGl2aXR5IHRvIGltcGxlbWVudCB0aGUgcHJvZ3JhbScsXG4gICAgW05PREVfVFlQRVMuT1VUUFVUXTogJ0RpcmVjdCByZXN1bHQgb2YgcHJvZ3JhbSBhY3Rpdml0aWVzJyxcbiAgICBbTk9ERV9UWVBFUy5JTlRFUk1FRElBVEVfT1VUQ09NRV06ICdNZWRpdW0tdGVybSBjaGFuZ2UgcmVzdWx0aW5nIGZyb20gb3V0cHV0cycsXG4gICAgW05PREVfVFlQRVMuRklOQUxfT1VUQ09NRV06ICdMb25nLXRlcm0gY2hhbmdlIHdlIGFpbSB0byBhY2hpZXZlJyxcbiAgICBbTk9ERV9UWVBFUy5JTVBBQ1RdOiAnVWx0aW1hdGUgc29jaWV0YWwgY2hhbmdlIHdlIGNvbnRyaWJ1dGUgdG8nXG4gIH07XG4gIHJldHVybiBkZXNjcmlwdGlvbnNbdHlwZV0gfHwgJ0Rlc2NyaXB0aW9uIGZvciB0aGlzIG5vZGUnO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBzZWN0aW9uIHdpdGhpbiBhIGxpc3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVNlY3Rpb24obmFtZSA9ICdVbmdyb3VwZWQnLCBsaXN0SWQsIG9yZGVyID0gMCkge1xuICByZXR1cm4ge1xuICAgIGlkOiBnZW5lcmF0ZUlkKCksXG4gICAgbmFtZSxcbiAgICBsaXN0SWQsXG4gICAgb3JkZXIsXG4gICAgY29sbGFwc2VkOiBmYWxzZSxcbiAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICB9O1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBsaXN0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVMaXN0KG5hbWUsIGNvbG9yID0gJyM2YjcyODAnLCBvcmRlciA9IDAsIHR5cGUgPSAnaW50ZXJtZWRpYXRlJykge1xuICBjb25zdCBsaXN0SWQgPSBnZW5lcmF0ZUlkKCk7XG4gIC8vIENyZWF0ZSBkZWZhdWx0IFwiVW5ncm91cGVkXCIgc2VjdGlvbiBmb3IgdGhlIGxpc3RcbiAgY29uc3QgZGVmYXVsdFNlY3Rpb24gPSBjcmVhdGVTZWN0aW9uKCdVbmdyb3VwZWQnLCBsaXN0SWQsIDApO1xuICBcbiAgcmV0dXJuIHtcbiAgICBpZDogbGlzdElkLFxuICAgIG5hbWUsXG4gICAgY29sb3IsXG4gICAgb3JkZXIsXG4gICAgdHlwZSxcbiAgICBjb2xsYXBzZWQ6IGZhbHNlLFxuICAgIG5vZGVJZHM6IFtdLFxuICAgIHNlY3Rpb25zOiBbZGVmYXVsdFNlY3Rpb25dXG4gIH07XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IG5vZGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU5vZGUodGl0bGUsIGxpc3RJZCwgdHlwZSA9IE5PREVfVFlQRVMuQUNUSVZJVFksIHNlY3Rpb25JZCA9IG51bGwpIHtcbiAgcmV0dXJuIHtcbiAgICBpZDogZ2VuZXJhdGVJZCgpLFxuICAgIHRpdGxlLFxuICAgIGRlc2NyaXB0aW9uOiAnJyxcbiAgICBsaXN0SWQsXG4gICAgc2VjdGlvbklkLCAvLyBudWxsIG1lYW5zIHVuZ3JvdXBlZCAod2lsbCBiZSBhc3NpZ25lZCB0byBmaXJzdCBzZWN0aW9uKVxuICAgIHR5cGUsXG4gICAgdGFnczogW10sXG4gICAgY29sb3I6ICcnLFxuICAgIHByaW9yaXR5OiAnbWVkaXVtJyxcbiAgICBvcmRlcjogMCwgLy8gRm9yIHNvcnRpbmcgd2l0aGluIGxpc3Qvc2VjdGlvblxuICAgIHBvc2l0aW9uOiB7IHg6IDAsIHk6IDAgfSwgLy8gRm9yIHZpc3VhbCBwb3NpdGlvbmluZ1xuICAgIHNpemU6IHsgd2lkdGg6IDIwMCwgaGVpZ2h0OiAxMDAgfSxcbiAgICBjb2xsYXBzZWQ6IGZhbHNlLFxuICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gIH07XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGVkZ2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUVkZ2Uoc291cmNlSWQsIHRhcmdldElkLCB0eXBlID0gRURHRV9UWVBFUy5MRUFEU19UTykge1xuICByZXR1cm4ge1xuICAgIGlkOiBnZW5lcmF0ZUlkKCksXG4gICAgc291cmNlSWQsXG4gICAgdGFyZ2V0SWQsXG4gICAgdHlwZSxcbiAgICBsYWJlbDogRURHRV9TVFlMRVNbdHlwZV0ubGFiZWwsXG4gICAgc3R5bGU6IEVER0VfU1RZTEVTW3R5cGVdLFxuICAgIGFuaW1hdGVkOiBmYWxzZSxcbiAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICB9O1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIGEgdW5pcXVlIElEXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlSWQoKSB7XG4gIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMiwgOSk7XG59Il0sIm5hbWVzIjpbIkRFRkFVTFRfTElTVFMiLCJpZCIsIm5hbWUiLCJjb2xvciIsIm9yZGVyIiwidHlwZSIsIkxJU1RfVFlQRVMiLCJGSVhFRCIsIklOVEVSTUVESUFURSIsIk5PREVfVFlQRVMiLCJBQ1RJVklUWSIsIk9VVFBVVCIsIklOVEVSTUVESUFURV9PVVRDT01FIiwiRklOQUxfT1VUQ09NRSIsIklNUEFDVCIsIkVER0VfVFlQRVMiLCJMRUFEU19UTyIsIkVOQUJMRVMiLCJSRVFVSVJFUyIsIkNPTlRSSUJVVEVTX1RPIiwiRURHRV9TVFlMRVMiLCJzdHJva2UiLCJzdHJva2VXaWR0aCIsInN0eWxlIiwibGFiZWwiLCJjcmVhdGVCb2FyZCIsImJvYXJkSWQiLCJnZW5lcmF0ZUlkIiwibGlzdHMiLCJtYXAiLCJsaXN0IiwiZGVmYXVsdFNlY3Rpb24iLCJjcmVhdGVTZWN0aW9uIiwibm9kZUlkcyIsInNlY3Rpb25zIiwic2FtcGxlTm9kZXMiLCJjcmVhdGVOb2RlIiwiZm9yRWFjaCIsIm5vZGUiLCJpbmRleCIsImxpc3ROb2RlcyIsImZpbHRlciIsIm4iLCJsaXN0SWQiLCJub2RlSW5kZXhJbkxpc3QiLCJmaW5kSW5kZXgiLCJkZXNjcmlwdGlvbiIsImdldE5vZGVEZXNjcmlwdGlvbiIsInRpdGxlIiwiZmluZCIsImwiLCJsZW5ndGgiLCJzZWN0aW9uSWQiLCJzYW1wbGVFZGdlcyIsImNyZWF0ZUVkZ2UiLCJub2RlcyIsImVkZ2VzIiwic2V0dGluZ3MiLCJzaG93TGFiZWxzIiwic25hcFRvR3JpZCIsImF1dG9MYXlvdXQiLCJ0aGVtZSIsImNyZWF0ZWRBdCIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsInVwZGF0ZWRBdCIsImRlc2NyaXB0aW9ucyIsImNvbGxhcHNlZCIsImNyZWF0ZUxpc3QiLCJ0YWdzIiwicHJpb3JpdHkiLCJwb3NpdGlvbiIsIngiLCJ5Iiwic2l6ZSIsIndpZHRoIiwiaGVpZ2h0Iiwic291cmNlSWQiLCJ0YXJnZXRJZCIsImFuaW1hdGVkIiwiTWF0aCIsInJhbmRvbSIsInRvU3RyaW5nIiwic3Vic3RyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/utils/tocModels.js\n"));

/***/ })

});