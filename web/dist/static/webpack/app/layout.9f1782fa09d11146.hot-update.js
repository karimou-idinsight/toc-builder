"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/layout",{

/***/ "(app-pages-browser)/./src/app/utils/tocModels.js":
/*!************************************!*\
  !*** ./src/app/utils/tocModels.js ***!
  \************************************/
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_LISTS: function() { return /* binding */ DEFAULT_LISTS; },\n/* harmony export */   EDGE_STYLES: function() { return /* binding */ EDGE_STYLES; },\n/* harmony export */   EDGE_TYPES: function() { return /* binding */ EDGE_TYPES; },\n/* harmony export */   LIST_TYPES: function() { return /* binding */ LIST_TYPES; },\n/* harmony export */   NODE_TYPES: function() { return /* binding */ NODE_TYPES; },\n/* harmony export */   createBoard: function() { return /* binding */ createBoard; },\n/* harmony export */   createEdge: function() { return /* binding */ createEdge; },\n/* harmony export */   createList: function() { return /* binding */ createList; },\n/* harmony export */   createNode: function() { return /* binding */ createNode; },\n/* harmony export */   createSection: function() { return /* binding */ createSection; }\n/* harmony export */ });\n/**\n * Theory of Change data models and types\n */ // Default list types for Theory of Change\nconst DEFAULT_LISTS = [\n    {\n        id: \"activities\",\n        name: \"Activities\",\n        color: \"#3b82f6\",\n        order: 0,\n        type: \"fixed\"\n    },\n    {\n        id: \"outputs\",\n        name: \"Outputs\",\n        color: \"#10b981\",\n        order: 1,\n        type: \"fixed\"\n    },\n    {\n        id: \"intermediate-1\",\n        name: \"Intermediate Outcomes 1\",\n        color: \"#f59e0b\",\n        order: 2,\n        type: \"intermediate\"\n    },\n    {\n        id: \"final-outcomes\",\n        name: \"Final Outcomes\",\n        color: \"#ef4444\",\n        order: 3,\n        type: \"fixed\"\n    },\n    {\n        id: \"impact\",\n        name: \"Impact\",\n        color: \"#8b5cf6\",\n        order: 4,\n        type: \"fixed\"\n    }\n];\n// List types\nconst LIST_TYPES = {\n    FIXED: \"fixed\",\n    INTERMEDIATE: \"intermediate\"\n};\n// Node types\nconst NODE_TYPES = {\n    ACTIVITY: \"activity\",\n    OUTPUT: \"output\",\n    INTERMEDIATE_OUTCOME: \"intermediate_outcome\",\n    FINAL_OUTCOME: \"final_outcome\",\n    IMPACT: \"impact\"\n};\n// Edge types\nconst EDGE_TYPES = {\n    LEADS_TO: \"leads_to\",\n    ENABLES: \"enables\",\n    REQUIRES: \"requires\",\n    CONTRIBUTES_TO: \"contributes_to\"\n};\n// Default edge styles\nconst EDGE_STYLES = {\n    [EDGE_TYPES.LEADS_TO]: {\n        stroke: \"#1355bfff\",\n        strokeWidth: 2,\n        style: \"solid\",\n        label: \"leads to\"\n    },\n    [EDGE_TYPES.ENABLES]: {\n        stroke: \"#10b981\",\n        strokeWidth: 2,\n        style: \"dashed\",\n        label: \"enables\"\n    },\n    [EDGE_TYPES.REQUIRES]: {\n        stroke: \"#ef4444\",\n        strokeWidth: 2,\n        style: \"dotted\",\n        label: \"requires\"\n    },\n    [EDGE_TYPES.CONTRIBUTES_TO]: {\n        stroke: \"#f59e0b\",\n        strokeWidth: 2,\n        style: \"solid\",\n        label: \"contributes to\"\n    }\n};\n/**\n * Create a new board\n */ function createBoard() {\n    let name = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \"Theory of Change Board\";\n    const boardId = generateId();\n    // Create lists with proper IDs\n    const lists = DEFAULT_LISTS.map((list)=>({\n            ...list,\n            id: list.id,\n            nodeIds: []\n        }));\n    // Create sample nodes\n    const sampleNodes = [\n        // Activities\n        createNode(\"Community Training Workshops\", \"activities\", NODE_TYPES.ACTIVITY),\n        createNode(\"Teacher Professional Development\", \"activities\", NODE_TYPES.ACTIVITY),\n        createNode(\"Digital Learning Platform Development\", \"activities\", NODE_TYPES.ACTIVITY),\n        createNode(\"Curriculum Design and Review\", \"activities\", NODE_TYPES.ACTIVITY),\n        // Outputs\n        createNode(\"500 Teachers Trained\", \"outputs\", NODE_TYPES.OUTPUT),\n        createNode(\"Online Learning Platform Launched\", \"outputs\", NODE_TYPES.OUTPUT),\n        createNode(\"Updated Curriculum Materials\", \"outputs\", NODE_TYPES.OUTPUT),\n        createNode(\"Community Learning Centers Established\", \"outputs\", NODE_TYPES.OUTPUT),\n        // Intermediate Outcomes\n        createNode(\"Improved Teaching Quality\", \"intermediate-1\", NODE_TYPES.INTERMEDIATE_OUTCOME),\n        createNode(\"Increased Student Engagement\", \"intermediate-1\", NODE_TYPES.INTERMEDIATE_OUTCOME),\n        createNode(\"Enhanced Digital Literacy\", \"intermediate-1\", NODE_TYPES.INTERMEDIATE_OUTCOME),\n        // Final Outcomes\n        createNode(\"Improved Student Learning Outcomes\", \"final-outcomes\", NODE_TYPES.FINAL_OUTCOME),\n        createNode(\"Reduced Educational Inequality\", \"final-outcomes\", NODE_TYPES.FINAL_OUTCOME),\n        createNode(\"Increased School Completion Rates\", \"final-outcomes\", NODE_TYPES.FINAL_OUTCOME),\n        // Impact\n        createNode(\"Sustainable Community Development\", \"impact\", NODE_TYPES.IMPACT),\n        createNode(\"Reduced Poverty in Target Communities\", \"impact\", NODE_TYPES.IMPACT)\n    ];\n    // Set proper order for nodes within each list\n    sampleNodes.forEach((node, index)=>{\n        const listNodes = sampleNodes.filter((n)=>n.listId === node.listId);\n        const nodeIndexInList = listNodes.findIndex((n)=>n.id === node.id);\n        node.order = nodeIndexInList;\n        node.description = getNodeDescription(node.title, node.type);\n    });\n    // Create some sample edges to show relationships\n    const sampleEdges = [\n        createEdge(sampleNodes[0].id, sampleNodes[4].id, EDGE_TYPES.LEADS_TO),\n        createEdge(sampleNodes[1].id, sampleNodes[4].id, EDGE_TYPES.LEADS_TO),\n        createEdge(sampleNodes[2].id, sampleNodes[5].id, EDGE_TYPES.LEADS_TO),\n        createEdge(sampleNodes[4].id, sampleNodes[8].id, EDGE_TYPES.LEADS_TO),\n        createEdge(sampleNodes[5].id, sampleNodes[10].id, EDGE_TYPES.LEADS_TO),\n        createEdge(sampleNodes[8].id, sampleNodes[11].id, EDGE_TYPES.LEADS_TO),\n        createEdge(sampleNodes[11].id, sampleNodes[15].id, EDGE_TYPES.CONTRIBUTES_TO)\n    ];\n    return {\n        id: boardId,\n        name,\n        description: \"A sample Theory of Change for education improvement\",\n        lists,\n        nodes: sampleNodes,\n        edges: sampleEdges,\n        settings: {\n            showLabels: true,\n            snapToGrid: false,\n            autoLayout: true,\n            theme: \"light\"\n        },\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString()\n    };\n}\n/**\n * Get sample description for a node based on its type\n */ function getNodeDescription(title, type) {\n    const descriptions = {\n        [NODE_TYPES.ACTIVITY]: \"Key activity to implement the program\",\n        [NODE_TYPES.OUTPUT]: \"Direct result of program activities\",\n        [NODE_TYPES.INTERMEDIATE_OUTCOME]: \"Medium-term change resulting from outputs\",\n        [NODE_TYPES.FINAL_OUTCOME]: \"Long-term change we aim to achieve\",\n        [NODE_TYPES.IMPACT]: \"Ultimate societal change we contribute to\"\n    };\n    return descriptions[type] || \"Description for this node\";\n}\n/**\n * Create a new section within a list\n */ function createSection() {\n    let name = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \"Ungrouped\", listId = arguments.length > 1 ? arguments[1] : void 0, order = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;\n    return {\n        id: generateId(),\n        name,\n        listId,\n        order,\n        collapsed: false,\n        createdAt: new Date().toISOString()\n    };\n}\n/**\n * Create a new list\n */ function createList(name) {\n    let color = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"#6b7280\", order = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, type = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : \"intermediate\";\n    const listId = generateId();\n    // Create default \"Ungrouped\" section for the list\n    const defaultSection = createSection(\"Ungrouped\", listId, 0);\n    return {\n        id: listId,\n        name,\n        color,\n        order,\n        type,\n        collapsed: false,\n        nodeIds: [],\n        sections: [\n            defaultSection\n        ]\n    };\n}\n/**\n * Create a new node\n */ function createNode(title, listId) {\n    let type = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : NODE_TYPES.ACTIVITY, sectionId = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;\n    return {\n        id: generateId(),\n        title,\n        description: \"\",\n        listId,\n        sectionId,\n        type,\n        tags: [],\n        color: \"\",\n        priority: \"medium\",\n        order: 0,\n        position: {\n            x: 0,\n            y: 0\n        },\n        size: {\n            width: 200,\n            height: 100\n        },\n        collapsed: false,\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString()\n    };\n}\n/**\n * Create a new edge\n */ function createEdge(sourceId, targetId) {\n    let type = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : EDGE_TYPES.LEADS_TO;\n    return {\n        id: generateId(),\n        sourceId,\n        targetId,\n        type,\n        label: EDGE_STYLES[type].label,\n        style: EDGE_STYLES[type],\n        animated: false,\n        createdAt: new Date().toISOString()\n    };\n}\n/**\n * Generate a unique ID\n */ function generateId() {\n    return Math.random().toString(36).substr(2, 9);\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = __webpack_module__.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = __webpack_module__.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, __webpack_module__.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                __webpack_module__.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                __webpack_module__.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        __webpack_module__.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    __webpack_module__.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvdXRpbHMvdG9jTW9kZWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Q0FFQyxHQUVELDBDQUEwQztBQUNuQyxNQUFNQSxnQkFBZ0I7SUFDM0I7UUFBRUMsSUFBSTtRQUFjQyxNQUFNO1FBQWNDLE9BQU87UUFBV0MsT0FBTztRQUFHQyxNQUFNO0lBQVE7SUFDbEY7UUFBRUosSUFBSTtRQUFXQyxNQUFNO1FBQVdDLE9BQU87UUFBV0MsT0FBTztRQUFHQyxNQUFNO0lBQVE7SUFDNUU7UUFBRUosSUFBSTtRQUFrQkMsTUFBTTtRQUEyQkMsT0FBTztRQUFXQyxPQUFPO1FBQUdDLE1BQU07SUFBZTtJQUMxRztRQUFFSixJQUFJO1FBQWtCQyxNQUFNO1FBQWtCQyxPQUFPO1FBQVdDLE9BQU87UUFBR0MsTUFBTTtJQUFRO0lBQzFGO1FBQUVKLElBQUk7UUFBVUMsTUFBTTtRQUFVQyxPQUFPO1FBQVdDLE9BQU87UUFBR0MsTUFBTTtJQUFRO0NBQzNFLENBQUM7QUFFRixhQUFhO0FBQ04sTUFBTUMsYUFBYTtJQUN4QkMsT0FBTztJQUNQQyxjQUFjO0FBQ2hCLEVBQUU7QUFFRixhQUFhO0FBQ04sTUFBTUMsYUFBYTtJQUN4QkMsVUFBVTtJQUNWQyxRQUFRO0lBQ1JDLHNCQUFzQjtJQUN0QkMsZUFBZTtJQUNmQyxRQUFRO0FBQ1YsRUFBRTtBQUVGLGFBQWE7QUFDTixNQUFNQyxhQUFhO0lBQ3hCQyxVQUFVO0lBQ1ZDLFNBQVM7SUFDVEMsVUFBVTtJQUNWQyxnQkFBZ0I7QUFDbEIsRUFBRTtBQUVGLHNCQUFzQjtBQUNmLE1BQU1DLGNBQWM7SUFDekIsQ0FBQ0wsV0FBV0MsUUFBUSxDQUFDLEVBQUU7UUFDckJLLFFBQVE7UUFDUkMsYUFBYTtRQUNiQyxPQUFPO1FBQ1BDLE9BQU87SUFDVDtJQUNBLENBQUNULFdBQVdFLE9BQU8sQ0FBQyxFQUFFO1FBQ3BCSSxRQUFRO1FBQ1JDLGFBQWE7UUFDYkMsT0FBTztRQUNQQyxPQUFPO0lBQ1Q7SUFDQSxDQUFDVCxXQUFXRyxRQUFRLENBQUMsRUFBRTtRQUNyQkcsUUFBUTtRQUNSQyxhQUFhO1FBQ2JDLE9BQU87UUFDUEMsT0FBTztJQUNUO0lBQ0EsQ0FBQ1QsV0FBV0ksY0FBYyxDQUFDLEVBQUU7UUFDM0JFLFFBQVE7UUFDUkMsYUFBYTtRQUNiQyxPQUFPO1FBQ1BDLE9BQU87SUFDVDtBQUNGLEVBQUU7QUFFRjs7Q0FFQyxHQUNNLFNBQVNDO1FBQVl2QixPQUFBQSxpRUFBTztJQUNqQyxNQUFNd0IsVUFBVUM7SUFFaEIsK0JBQStCO0lBQy9CLE1BQU1DLFFBQVE1QixjQUFjNkIsR0FBRyxDQUFDQyxDQUFBQSxPQUFTO1lBQ3ZDLEdBQUdBLElBQUk7WUFDUDdCLElBQUk2QixLQUFLN0IsRUFBRTtZQUNYOEIsU0FBUyxFQUFFO1FBQ2I7SUFFQSxzQkFBc0I7SUFDdEIsTUFBTUMsY0FBYztRQUNsQixhQUFhO1FBQ2JDLFdBQVcsZ0NBQWdDLGNBQWN4QixXQUFXQyxRQUFRO1FBQzVFdUIsV0FBVyxvQ0FBb0MsY0FBY3hCLFdBQVdDLFFBQVE7UUFDaEZ1QixXQUFXLHlDQUF5QyxjQUFjeEIsV0FBV0MsUUFBUTtRQUNyRnVCLFdBQVcsZ0NBQWdDLGNBQWN4QixXQUFXQyxRQUFRO1FBRTVFLFVBQVU7UUFDVnVCLFdBQVcsd0JBQXdCLFdBQVd4QixXQUFXRSxNQUFNO1FBQy9Ec0IsV0FBVyxxQ0FBcUMsV0FBV3hCLFdBQVdFLE1BQU07UUFDNUVzQixXQUFXLGdDQUFnQyxXQUFXeEIsV0FBV0UsTUFBTTtRQUN2RXNCLFdBQVcsMENBQTBDLFdBQVd4QixXQUFXRSxNQUFNO1FBRWpGLHdCQUF3QjtRQUN4QnNCLFdBQVcsNkJBQTZCLGtCQUFrQnhCLFdBQVdHLG9CQUFvQjtRQUN6RnFCLFdBQVcsZ0NBQWdDLGtCQUFrQnhCLFdBQVdHLG9CQUFvQjtRQUM1RnFCLFdBQVcsNkJBQTZCLGtCQUFrQnhCLFdBQVdHLG9CQUFvQjtRQUV6RixpQkFBaUI7UUFDakJxQixXQUFXLHNDQUFzQyxrQkFBa0J4QixXQUFXSSxhQUFhO1FBQzNGb0IsV0FBVyxrQ0FBa0Msa0JBQWtCeEIsV0FBV0ksYUFBYTtRQUN2Rm9CLFdBQVcscUNBQXFDLGtCQUFrQnhCLFdBQVdJLGFBQWE7UUFFMUYsU0FBUztRQUNUb0IsV0FBVyxxQ0FBcUMsVUFBVXhCLFdBQVdLLE1BQU07UUFDM0VtQixXQUFXLHlDQUF5QyxVQUFVeEIsV0FBV0ssTUFBTTtLQUNoRjtJQUVELDhDQUE4QztJQUM5Q2tCLFlBQVlFLE9BQU8sQ0FBQyxDQUFDQyxNQUFNQztRQUN6QixNQUFNQyxZQUFZTCxZQUFZTSxNQUFNLENBQUNDLENBQUFBLElBQUtBLEVBQUVDLE1BQU0sS0FBS0wsS0FBS0ssTUFBTTtRQUNsRSxNQUFNQyxrQkFBa0JKLFVBQVVLLFNBQVMsQ0FBQ0gsQ0FBQUEsSUFBS0EsRUFBRXRDLEVBQUUsS0FBS2tDLEtBQUtsQyxFQUFFO1FBQ2pFa0MsS0FBSy9CLEtBQUssR0FBR3FDO1FBQ2JOLEtBQUtRLFdBQVcsR0FBR0MsbUJBQW1CVCxLQUFLVSxLQUFLLEVBQUVWLEtBQUs5QixJQUFJO0lBQzdEO0lBRUEsaURBQWlEO0lBQ2pELE1BQU15QyxjQUFjO1FBQ2xCQyxXQUFXZixXQUFXLENBQUMsRUFBRSxDQUFDL0IsRUFBRSxFQUFFK0IsV0FBVyxDQUFDLEVBQUUsQ0FBQy9CLEVBQUUsRUFBRWMsV0FBV0MsUUFBUTtRQUNwRStCLFdBQVdmLFdBQVcsQ0FBQyxFQUFFLENBQUMvQixFQUFFLEVBQUUrQixXQUFXLENBQUMsRUFBRSxDQUFDL0IsRUFBRSxFQUFFYyxXQUFXQyxRQUFRO1FBQ3BFK0IsV0FBV2YsV0FBVyxDQUFDLEVBQUUsQ0FBQy9CLEVBQUUsRUFBRStCLFdBQVcsQ0FBQyxFQUFFLENBQUMvQixFQUFFLEVBQUVjLFdBQVdDLFFBQVE7UUFDcEUrQixXQUFXZixXQUFXLENBQUMsRUFBRSxDQUFDL0IsRUFBRSxFQUFFK0IsV0FBVyxDQUFDLEVBQUUsQ0FBQy9CLEVBQUUsRUFBRWMsV0FBV0MsUUFBUTtRQUNwRStCLFdBQVdmLFdBQVcsQ0FBQyxFQUFFLENBQUMvQixFQUFFLEVBQUUrQixXQUFXLENBQUMsR0FBRyxDQUFDL0IsRUFBRSxFQUFFYyxXQUFXQyxRQUFRO1FBQ3JFK0IsV0FBV2YsV0FBVyxDQUFDLEVBQUUsQ0FBQy9CLEVBQUUsRUFBRStCLFdBQVcsQ0FBQyxHQUFHLENBQUMvQixFQUFFLEVBQUVjLFdBQVdDLFFBQVE7UUFDckUrQixXQUFXZixXQUFXLENBQUMsR0FBRyxDQUFDL0IsRUFBRSxFQUFFK0IsV0FBVyxDQUFDLEdBQUcsQ0FBQy9CLEVBQUUsRUFBRWMsV0FBV0ksY0FBYztLQUM3RTtJQUVELE9BQU87UUFDTGxCLElBQUl5QjtRQUNKeEI7UUFDQXlDLGFBQWE7UUFDYmY7UUFDQW9CLE9BQU9oQjtRQUNQaUIsT0FBT0g7UUFDUEksVUFBVTtZQUNSQyxZQUFZO1lBQ1pDLFlBQVk7WUFDWkMsWUFBWTtZQUNaQyxPQUFPO1FBQ1Q7UUFDQUMsV0FBVyxJQUFJQyxPQUFPQyxXQUFXO1FBQ2pDQyxXQUFXLElBQUlGLE9BQU9DLFdBQVc7SUFDbkM7QUFDRjtBQUVBOztDQUVDLEdBQ0QsU0FBU2IsbUJBQW1CQyxLQUFLLEVBQUV4QyxJQUFJO0lBQ3JDLE1BQU1zRCxlQUFlO1FBQ25CLENBQUNsRCxXQUFXQyxRQUFRLENBQUMsRUFBRTtRQUN2QixDQUFDRCxXQUFXRSxNQUFNLENBQUMsRUFBRTtRQUNyQixDQUFDRixXQUFXRyxvQkFBb0IsQ0FBQyxFQUFFO1FBQ25DLENBQUNILFdBQVdJLGFBQWEsQ0FBQyxFQUFFO1FBQzVCLENBQUNKLFdBQVdLLE1BQU0sQ0FBQyxFQUFFO0lBQ3ZCO0lBQ0EsT0FBTzZDLFlBQVksQ0FBQ3RELEtBQUssSUFBSTtBQUMvQjtBQUVBOztDQUVDLEdBQ00sU0FBU3VEO1FBQWMxRCxPQUFBQSxpRUFBTyxhQUFhc0MsdURBQVFwQyxRQUFBQSxpRUFBUTtJQUNoRSxPQUFPO1FBQ0xILElBQUkwQjtRQUNKekI7UUFDQXNDO1FBQ0FwQztRQUNBeUQsV0FBVztRQUNYTixXQUFXLElBQUlDLE9BQU9DLFdBQVc7SUFDbkM7QUFDRjtBQUVBOztDQUVDLEdBQ00sU0FBU0ssV0FBVzVELElBQUk7UUFBRUMsUUFBQUEsaUVBQVEsV0FBV0MsUUFBQUEsaUVBQVEsR0FBR0MsT0FBQUEsaUVBQU87SUFDcEUsTUFBTW1DLFNBQVNiO0lBQ2Ysa0RBQWtEO0lBQ2xELE1BQU1vQyxpQkFBaUJILGNBQWMsYUFBYXBCLFFBQVE7SUFFMUQsT0FBTztRQUNMdkMsSUFBSXVDO1FBQ0p0QztRQUNBQztRQUNBQztRQUNBQztRQUNBd0QsV0FBVztRQUNYOUIsU0FBUyxFQUFFO1FBQ1hpQyxVQUFVO1lBQUNEO1NBQWU7SUFDNUI7QUFDRjtBQUVBOztDQUVDLEdBQ00sU0FBUzlCLFdBQVdZLEtBQUssRUFBRUwsTUFBTTtRQUFFbkMsT0FBQUEsaUVBQU9JLFdBQVdDLFFBQVEsRUFBRXVELFlBQUFBLGlFQUFZO0lBQ2hGLE9BQU87UUFDTGhFLElBQUkwQjtRQUNKa0I7UUFDQUYsYUFBYTtRQUNiSDtRQUNBeUI7UUFDQTVEO1FBQ0E2RCxNQUFNLEVBQUU7UUFDUi9ELE9BQU87UUFDUGdFLFVBQVU7UUFDVi9ELE9BQU87UUFDUGdFLFVBQVU7WUFBRUMsR0FBRztZQUFHQyxHQUFHO1FBQUU7UUFDdkJDLE1BQU07WUFBRUMsT0FBTztZQUFLQyxRQUFRO1FBQUk7UUFDaENaLFdBQVc7UUFDWE4sV0FBVyxJQUFJQyxPQUFPQyxXQUFXO1FBQ2pDQyxXQUFXLElBQUlGLE9BQU9DLFdBQVc7SUFDbkM7QUFDRjtBQUVBOztDQUVDLEdBQ00sU0FBU1YsV0FBVzJCLFFBQVEsRUFBRUMsUUFBUTtRQUFFdEUsT0FBQUEsaUVBQU9VLFdBQVdDLFFBQVE7SUFDdkUsT0FBTztRQUNMZixJQUFJMEI7UUFDSitDO1FBQ0FDO1FBQ0F0RTtRQUNBbUIsT0FBT0osV0FBVyxDQUFDZixLQUFLLENBQUNtQixLQUFLO1FBQzlCRCxPQUFPSCxXQUFXLENBQUNmLEtBQUs7UUFDeEJ1RSxVQUFVO1FBQ1ZyQixXQUFXLElBQUlDLE9BQU9DLFdBQVc7SUFDbkM7QUFDRjtBQUVBOztDQUVDLEdBQ0QsU0FBUzlCO0lBQ1AsT0FBT2tELEtBQUtDLE1BQU0sR0FBR0MsUUFBUSxDQUFDLElBQUlDLE1BQU0sQ0FBQyxHQUFHO0FBQzlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9hcHAvdXRpbHMvdG9jTW9kZWxzLmpzPzViYTkiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBUaGVvcnkgb2YgQ2hhbmdlIGRhdGEgbW9kZWxzIGFuZCB0eXBlc1xuICovXG5cbi8vIERlZmF1bHQgbGlzdCB0eXBlcyBmb3IgVGhlb3J5IG9mIENoYW5nZVxuZXhwb3J0IGNvbnN0IERFRkFVTFRfTElTVFMgPSBbXG4gIHsgaWQ6ICdhY3Rpdml0aWVzJywgbmFtZTogJ0FjdGl2aXRpZXMnLCBjb2xvcjogJyMzYjgyZjYnLCBvcmRlcjogMCwgdHlwZTogJ2ZpeGVkJyB9LFxuICB7IGlkOiAnb3V0cHV0cycsIG5hbWU6ICdPdXRwdXRzJywgY29sb3I6ICcjMTBiOTgxJywgb3JkZXI6IDEsIHR5cGU6ICdmaXhlZCcgfSxcbiAgeyBpZDogJ2ludGVybWVkaWF0ZS0xJywgbmFtZTogJ0ludGVybWVkaWF0ZSBPdXRjb21lcyAxJywgY29sb3I6ICcjZjU5ZTBiJywgb3JkZXI6IDIsIHR5cGU6ICdpbnRlcm1lZGlhdGUnIH0sXG4gIHsgaWQ6ICdmaW5hbC1vdXRjb21lcycsIG5hbWU6ICdGaW5hbCBPdXRjb21lcycsIGNvbG9yOiAnI2VmNDQ0NCcsIG9yZGVyOiAzLCB0eXBlOiAnZml4ZWQnIH0sXG4gIHsgaWQ6ICdpbXBhY3QnLCBuYW1lOiAnSW1wYWN0JywgY29sb3I6ICcjOGI1Y2Y2Jywgb3JkZXI6IDQsIHR5cGU6ICdmaXhlZCcgfVxuXTtcblxuLy8gTGlzdCB0eXBlc1xuZXhwb3J0IGNvbnN0IExJU1RfVFlQRVMgPSB7XG4gIEZJWEVEOiAnZml4ZWQnLFxuICBJTlRFUk1FRElBVEU6ICdpbnRlcm1lZGlhdGUnXG59O1xuXG4vLyBOb2RlIHR5cGVzXG5leHBvcnQgY29uc3QgTk9ERV9UWVBFUyA9IHtcbiAgQUNUSVZJVFk6ICdhY3Rpdml0eScsXG4gIE9VVFBVVDogJ291dHB1dCcsXG4gIElOVEVSTUVESUFURV9PVVRDT01FOiAnaW50ZXJtZWRpYXRlX291dGNvbWUnLFxuICBGSU5BTF9PVVRDT01FOiAnZmluYWxfb3V0Y29tZScsXG4gIElNUEFDVDogJ2ltcGFjdCdcbn07XG5cbi8vIEVkZ2UgdHlwZXNcbmV4cG9ydCBjb25zdCBFREdFX1RZUEVTID0ge1xuICBMRUFEU19UTzogJ2xlYWRzX3RvJyxcbiAgRU5BQkxFUzogJ2VuYWJsZXMnLFxuICBSRVFVSVJFUzogJ3JlcXVpcmVzJyxcbiAgQ09OVFJJQlVURVNfVE86ICdjb250cmlidXRlc190bydcbn07XG5cbi8vIERlZmF1bHQgZWRnZSBzdHlsZXNcbmV4cG9ydCBjb25zdCBFREdFX1NUWUxFUyA9IHtcbiAgW0VER0VfVFlQRVMuTEVBRFNfVE9dOiB7XG4gICAgc3Ryb2tlOiAnIzEzNTViZmZmJyxcbiAgICBzdHJva2VXaWR0aDogMixcbiAgICBzdHlsZTogJ3NvbGlkJyxcbiAgICBsYWJlbDogJ2xlYWRzIHRvJ1xuICB9LFxuICBbRURHRV9UWVBFUy5FTkFCTEVTXToge1xuICAgIHN0cm9rZTogJyMxMGI5ODEnLFxuICAgIHN0cm9rZVdpZHRoOiAyLFxuICAgIHN0eWxlOiAnZGFzaGVkJyxcbiAgICBsYWJlbDogJ2VuYWJsZXMnXG4gIH0sXG4gIFtFREdFX1RZUEVTLlJFUVVJUkVTXToge1xuICAgIHN0cm9rZTogJyNlZjQ0NDQnLFxuICAgIHN0cm9rZVdpZHRoOiAyLFxuICAgIHN0eWxlOiAnZG90dGVkJyxcbiAgICBsYWJlbDogJ3JlcXVpcmVzJ1xuICB9LFxuICBbRURHRV9UWVBFUy5DT05UUklCVVRFU19UT106IHtcbiAgICBzdHJva2U6ICcjZjU5ZTBiJyxcbiAgICBzdHJva2VXaWR0aDogMixcbiAgICBzdHlsZTogJ3NvbGlkJyxcbiAgICBsYWJlbDogJ2NvbnRyaWJ1dGVzIHRvJ1xuICB9XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBib2FyZFxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQm9hcmQobmFtZSA9ICdUaGVvcnkgb2YgQ2hhbmdlIEJvYXJkJykge1xuICBjb25zdCBib2FyZElkID0gZ2VuZXJhdGVJZCgpO1xuICBcbiAgLy8gQ3JlYXRlIGxpc3RzIHdpdGggcHJvcGVyIElEc1xuICBjb25zdCBsaXN0cyA9IERFRkFVTFRfTElTVFMubWFwKGxpc3QgPT4gKHsgXG4gICAgLi4ubGlzdCwgXG4gICAgaWQ6IGxpc3QuaWQsIC8vIEtlZXAgdGhlIHByZWRlZmluZWQgSURzIGZvciBjb25zaXN0ZW5jeVxuICAgIG5vZGVJZHM6IFtdXG4gIH0pKTtcblxuICAvLyBDcmVhdGUgc2FtcGxlIG5vZGVzXG4gIGNvbnN0IHNhbXBsZU5vZGVzID0gW1xuICAgIC8vIEFjdGl2aXRpZXNcbiAgICBjcmVhdGVOb2RlKCdDb21tdW5pdHkgVHJhaW5pbmcgV29ya3Nob3BzJywgJ2FjdGl2aXRpZXMnLCBOT0RFX1RZUEVTLkFDVElWSVRZKSxcbiAgICBjcmVhdGVOb2RlKCdUZWFjaGVyIFByb2Zlc3Npb25hbCBEZXZlbG9wbWVudCcsICdhY3Rpdml0aWVzJywgTk9ERV9UWVBFUy5BQ1RJVklUWSksXG4gICAgY3JlYXRlTm9kZSgnRGlnaXRhbCBMZWFybmluZyBQbGF0Zm9ybSBEZXZlbG9wbWVudCcsICdhY3Rpdml0aWVzJywgTk9ERV9UWVBFUy5BQ1RJVklUWSksXG4gICAgY3JlYXRlTm9kZSgnQ3VycmljdWx1bSBEZXNpZ24gYW5kIFJldmlldycsICdhY3Rpdml0aWVzJywgTk9ERV9UWVBFUy5BQ1RJVklUWSksXG4gICAgXG4gICAgLy8gT3V0cHV0c1xuICAgIGNyZWF0ZU5vZGUoJzUwMCBUZWFjaGVycyBUcmFpbmVkJywgJ291dHB1dHMnLCBOT0RFX1RZUEVTLk9VVFBVVCksXG4gICAgY3JlYXRlTm9kZSgnT25saW5lIExlYXJuaW5nIFBsYXRmb3JtIExhdW5jaGVkJywgJ291dHB1dHMnLCBOT0RFX1RZUEVTLk9VVFBVVCksXG4gICAgY3JlYXRlTm9kZSgnVXBkYXRlZCBDdXJyaWN1bHVtIE1hdGVyaWFscycsICdvdXRwdXRzJywgTk9ERV9UWVBFUy5PVVRQVVQpLFxuICAgIGNyZWF0ZU5vZGUoJ0NvbW11bml0eSBMZWFybmluZyBDZW50ZXJzIEVzdGFibGlzaGVkJywgJ291dHB1dHMnLCBOT0RFX1RZUEVTLk9VVFBVVCksXG4gICAgXG4gICAgLy8gSW50ZXJtZWRpYXRlIE91dGNvbWVzXG4gICAgY3JlYXRlTm9kZSgnSW1wcm92ZWQgVGVhY2hpbmcgUXVhbGl0eScsICdpbnRlcm1lZGlhdGUtMScsIE5PREVfVFlQRVMuSU5URVJNRURJQVRFX09VVENPTUUpLFxuICAgIGNyZWF0ZU5vZGUoJ0luY3JlYXNlZCBTdHVkZW50IEVuZ2FnZW1lbnQnLCAnaW50ZXJtZWRpYXRlLTEnLCBOT0RFX1RZUEVTLklOVEVSTUVESUFURV9PVVRDT01FKSxcbiAgICBjcmVhdGVOb2RlKCdFbmhhbmNlZCBEaWdpdGFsIExpdGVyYWN5JywgJ2ludGVybWVkaWF0ZS0xJywgTk9ERV9UWVBFUy5JTlRFUk1FRElBVEVfT1VUQ09NRSksXG4gICAgXG4gICAgLy8gRmluYWwgT3V0Y29tZXNcbiAgICBjcmVhdGVOb2RlKCdJbXByb3ZlZCBTdHVkZW50IExlYXJuaW5nIE91dGNvbWVzJywgJ2ZpbmFsLW91dGNvbWVzJywgTk9ERV9UWVBFUy5GSU5BTF9PVVRDT01FKSxcbiAgICBjcmVhdGVOb2RlKCdSZWR1Y2VkIEVkdWNhdGlvbmFsIEluZXF1YWxpdHknLCAnZmluYWwtb3V0Y29tZXMnLCBOT0RFX1RZUEVTLkZJTkFMX09VVENPTUUpLFxuICAgIGNyZWF0ZU5vZGUoJ0luY3JlYXNlZCBTY2hvb2wgQ29tcGxldGlvbiBSYXRlcycsICdmaW5hbC1vdXRjb21lcycsIE5PREVfVFlQRVMuRklOQUxfT1VUQ09NRSksXG4gICAgXG4gICAgLy8gSW1wYWN0XG4gICAgY3JlYXRlTm9kZSgnU3VzdGFpbmFibGUgQ29tbXVuaXR5IERldmVsb3BtZW50JywgJ2ltcGFjdCcsIE5PREVfVFlQRVMuSU1QQUNUKSxcbiAgICBjcmVhdGVOb2RlKCdSZWR1Y2VkIFBvdmVydHkgaW4gVGFyZ2V0IENvbW11bml0aWVzJywgJ2ltcGFjdCcsIE5PREVfVFlQRVMuSU1QQUNUKVxuICBdO1xuXG4gIC8vIFNldCBwcm9wZXIgb3JkZXIgZm9yIG5vZGVzIHdpdGhpbiBlYWNoIGxpc3RcbiAgc2FtcGxlTm9kZXMuZm9yRWFjaCgobm9kZSwgaW5kZXgpID0+IHtcbiAgICBjb25zdCBsaXN0Tm9kZXMgPSBzYW1wbGVOb2Rlcy5maWx0ZXIobiA9PiBuLmxpc3RJZCA9PT0gbm9kZS5saXN0SWQpO1xuICAgIGNvbnN0IG5vZGVJbmRleEluTGlzdCA9IGxpc3ROb2Rlcy5maW5kSW5kZXgobiA9PiBuLmlkID09PSBub2RlLmlkKTtcbiAgICBub2RlLm9yZGVyID0gbm9kZUluZGV4SW5MaXN0O1xuICAgIG5vZGUuZGVzY3JpcHRpb24gPSBnZXROb2RlRGVzY3JpcHRpb24obm9kZS50aXRsZSwgbm9kZS50eXBlKTtcbiAgfSk7XG5cbiAgLy8gQ3JlYXRlIHNvbWUgc2FtcGxlIGVkZ2VzIHRvIHNob3cgcmVsYXRpb25zaGlwc1xuICBjb25zdCBzYW1wbGVFZGdlcyA9IFtcbiAgICBjcmVhdGVFZGdlKHNhbXBsZU5vZGVzWzBdLmlkLCBzYW1wbGVOb2Rlc1s0XS5pZCwgRURHRV9UWVBFUy5MRUFEU19UTyksIC8vIFRyYWluaW5nIC0+IFRlYWNoZXJzIFRyYWluZWRcbiAgICBjcmVhdGVFZGdlKHNhbXBsZU5vZGVzWzFdLmlkLCBzYW1wbGVOb2Rlc1s0XS5pZCwgRURHRV9UWVBFUy5MRUFEU19UTyksIC8vIFByb2YgRGV2IC0+IFRlYWNoZXJzIFRyYWluZWRcbiAgICBjcmVhdGVFZGdlKHNhbXBsZU5vZGVzWzJdLmlkLCBzYW1wbGVOb2Rlc1s1XS5pZCwgRURHRV9UWVBFUy5MRUFEU19UTyksIC8vIFBsYXRmb3JtIERldiAtPiBQbGF0Zm9ybSBMYXVuY2hlZFxuICAgIGNyZWF0ZUVkZ2Uoc2FtcGxlTm9kZXNbNF0uaWQsIHNhbXBsZU5vZGVzWzhdLmlkLCBFREdFX1RZUEVTLkxFQURTX1RPKSwgLy8gVGVhY2hlcnMgVHJhaW5lZCAtPiBUZWFjaGluZyBRdWFsaXR5XG4gICAgY3JlYXRlRWRnZShzYW1wbGVOb2Rlc1s1XS5pZCwgc2FtcGxlTm9kZXNbMTBdLmlkLCBFREdFX1RZUEVTLkxFQURTX1RPKSwgLy8gUGxhdGZvcm0gLT4gRGlnaXRhbCBMaXRlcmFjeVxuICAgIGNyZWF0ZUVkZ2Uoc2FtcGxlTm9kZXNbOF0uaWQsIHNhbXBsZU5vZGVzWzExXS5pZCwgRURHRV9UWVBFUy5MRUFEU19UTyksIC8vIFRlYWNoaW5nIFF1YWxpdHkgLT4gTGVhcm5pbmcgT3V0Y29tZXNcbiAgICBjcmVhdGVFZGdlKHNhbXBsZU5vZGVzWzExXS5pZCwgc2FtcGxlTm9kZXNbMTVdLmlkLCBFREdFX1RZUEVTLkNPTlRSSUJVVEVTX1RPKSwgLy8gTGVhcm5pbmcgLT4gRGV2ZWxvcG1lbnRcbiAgXTtcblxuICByZXR1cm4ge1xuICAgIGlkOiBib2FyZElkLFxuICAgIG5hbWUsXG4gICAgZGVzY3JpcHRpb246ICdBIHNhbXBsZSBUaGVvcnkgb2YgQ2hhbmdlIGZvciBlZHVjYXRpb24gaW1wcm92ZW1lbnQnLFxuICAgIGxpc3RzLFxuICAgIG5vZGVzOiBzYW1wbGVOb2RlcyxcbiAgICBlZGdlczogc2FtcGxlRWRnZXMsXG4gICAgc2V0dGluZ3M6IHtcbiAgICAgIHNob3dMYWJlbHM6IHRydWUsXG4gICAgICBzbmFwVG9HcmlkOiBmYWxzZSxcbiAgICAgIGF1dG9MYXlvdXQ6IHRydWUsXG4gICAgICB0aGVtZTogJ2xpZ2h0J1xuICAgIH0sXG4gICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgfTtcbn1cblxuLyoqXG4gKiBHZXQgc2FtcGxlIGRlc2NyaXB0aW9uIGZvciBhIG5vZGUgYmFzZWQgb24gaXRzIHR5cGVcbiAqL1xuZnVuY3Rpb24gZ2V0Tm9kZURlc2NyaXB0aW9uKHRpdGxlLCB0eXBlKSB7XG4gIGNvbnN0IGRlc2NyaXB0aW9ucyA9IHtcbiAgICBbTk9ERV9UWVBFUy5BQ1RJVklUWV06ICdLZXkgYWN0aXZpdHkgdG8gaW1wbGVtZW50IHRoZSBwcm9ncmFtJyxcbiAgICBbTk9ERV9UWVBFUy5PVVRQVVRdOiAnRGlyZWN0IHJlc3VsdCBvZiBwcm9ncmFtIGFjdGl2aXRpZXMnLFxuICAgIFtOT0RFX1RZUEVTLklOVEVSTUVESUFURV9PVVRDT01FXTogJ01lZGl1bS10ZXJtIGNoYW5nZSByZXN1bHRpbmcgZnJvbSBvdXRwdXRzJyxcbiAgICBbTk9ERV9UWVBFUy5GSU5BTF9PVVRDT01FXTogJ0xvbmctdGVybSBjaGFuZ2Ugd2UgYWltIHRvIGFjaGlldmUnLFxuICAgIFtOT0RFX1RZUEVTLklNUEFDVF06ICdVbHRpbWF0ZSBzb2NpZXRhbCBjaGFuZ2Ugd2UgY29udHJpYnV0ZSB0bydcbiAgfTtcbiAgcmV0dXJuIGRlc2NyaXB0aW9uc1t0eXBlXSB8fCAnRGVzY3JpcHRpb24gZm9yIHRoaXMgbm9kZSc7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IHNlY3Rpb24gd2l0aGluIGEgbGlzdFxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU2VjdGlvbihuYW1lID0gJ1VuZ3JvdXBlZCcsIGxpc3RJZCwgb3JkZXIgPSAwKSB7XG4gIHJldHVybiB7XG4gICAgaWQ6IGdlbmVyYXRlSWQoKSxcbiAgICBuYW1lLFxuICAgIGxpc3RJZCxcbiAgICBvcmRlcixcbiAgICBjb2xsYXBzZWQ6IGZhbHNlLFxuICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gIH07XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGxpc3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUxpc3QobmFtZSwgY29sb3IgPSAnIzZiNzI4MCcsIG9yZGVyID0gMCwgdHlwZSA9ICdpbnRlcm1lZGlhdGUnKSB7XG4gIGNvbnN0IGxpc3RJZCA9IGdlbmVyYXRlSWQoKTtcbiAgLy8gQ3JlYXRlIGRlZmF1bHQgXCJVbmdyb3VwZWRcIiBzZWN0aW9uIGZvciB0aGUgbGlzdFxuICBjb25zdCBkZWZhdWx0U2VjdGlvbiA9IGNyZWF0ZVNlY3Rpb24oJ1VuZ3JvdXBlZCcsIGxpc3RJZCwgMCk7XG4gIFxuICByZXR1cm4ge1xuICAgIGlkOiBsaXN0SWQsXG4gICAgbmFtZSxcbiAgICBjb2xvcixcbiAgICBvcmRlcixcbiAgICB0eXBlLFxuICAgIGNvbGxhcHNlZDogZmFsc2UsXG4gICAgbm9kZUlkczogW10sXG4gICAgc2VjdGlvbnM6IFtkZWZhdWx0U2VjdGlvbl1cbiAgfTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgbm9kZVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTm9kZSh0aXRsZSwgbGlzdElkLCB0eXBlID0gTk9ERV9UWVBFUy5BQ1RJVklUWSwgc2VjdGlvbklkID0gbnVsbCkge1xuICByZXR1cm4ge1xuICAgIGlkOiBnZW5lcmF0ZUlkKCksXG4gICAgdGl0bGUsXG4gICAgZGVzY3JpcHRpb246ICcnLFxuICAgIGxpc3RJZCxcbiAgICBzZWN0aW9uSWQsIC8vIG51bGwgbWVhbnMgdW5ncm91cGVkICh3aWxsIGJlIGFzc2lnbmVkIHRvIGZpcnN0IHNlY3Rpb24pXG4gICAgdHlwZSxcbiAgICB0YWdzOiBbXSxcbiAgICBjb2xvcjogJycsXG4gICAgcHJpb3JpdHk6ICdtZWRpdW0nLFxuICAgIG9yZGVyOiAwLCAvLyBGb3Igc29ydGluZyB3aXRoaW4gbGlzdC9zZWN0aW9uXG4gICAgcG9zaXRpb246IHsgeDogMCwgeTogMCB9LCAvLyBGb3IgdmlzdWFsIHBvc2l0aW9uaW5nXG4gICAgc2l6ZTogeyB3aWR0aDogMjAwLCBoZWlnaHQ6IDEwMCB9LFxuICAgIGNvbGxhcHNlZDogZmFsc2UsXG4gICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgfTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgZWRnZVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRWRnZShzb3VyY2VJZCwgdGFyZ2V0SWQsIHR5cGUgPSBFREdFX1RZUEVTLkxFQURTX1RPKSB7XG4gIHJldHVybiB7XG4gICAgaWQ6IGdlbmVyYXRlSWQoKSxcbiAgICBzb3VyY2VJZCxcbiAgICB0YXJnZXRJZCxcbiAgICB0eXBlLFxuICAgIGxhYmVsOiBFREdFX1NUWUxFU1t0eXBlXS5sYWJlbCxcbiAgICBzdHlsZTogRURHRV9TVFlMRVNbdHlwZV0sXG4gICAgYW5pbWF0ZWQ6IGZhbHNlLFxuICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gIH07XG59XG5cbi8qKlxuICogR2VuZXJhdGUgYSB1bmlxdWUgSURcbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVJZCgpIHtcbiAgcmV0dXJuIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyLCA5KTtcbn0iXSwibmFtZXMiOlsiREVGQVVMVF9MSVNUUyIsImlkIiwibmFtZSIsImNvbG9yIiwib3JkZXIiLCJ0eXBlIiwiTElTVF9UWVBFUyIsIkZJWEVEIiwiSU5URVJNRURJQVRFIiwiTk9ERV9UWVBFUyIsIkFDVElWSVRZIiwiT1VUUFVUIiwiSU5URVJNRURJQVRFX09VVENPTUUiLCJGSU5BTF9PVVRDT01FIiwiSU1QQUNUIiwiRURHRV9UWVBFUyIsIkxFQURTX1RPIiwiRU5BQkxFUyIsIlJFUVVJUkVTIiwiQ09OVFJJQlVURVNfVE8iLCJFREdFX1NUWUxFUyIsInN0cm9rZSIsInN0cm9rZVdpZHRoIiwic3R5bGUiLCJsYWJlbCIsImNyZWF0ZUJvYXJkIiwiYm9hcmRJZCIsImdlbmVyYXRlSWQiLCJsaXN0cyIsIm1hcCIsImxpc3QiLCJub2RlSWRzIiwic2FtcGxlTm9kZXMiLCJjcmVhdGVOb2RlIiwiZm9yRWFjaCIsIm5vZGUiLCJpbmRleCIsImxpc3ROb2RlcyIsImZpbHRlciIsIm4iLCJsaXN0SWQiLCJub2RlSW5kZXhJbkxpc3QiLCJmaW5kSW5kZXgiLCJkZXNjcmlwdGlvbiIsImdldE5vZGVEZXNjcmlwdGlvbiIsInRpdGxlIiwic2FtcGxlRWRnZXMiLCJjcmVhdGVFZGdlIiwibm9kZXMiLCJlZGdlcyIsInNldHRpbmdzIiwic2hvd0xhYmVscyIsInNuYXBUb0dyaWQiLCJhdXRvTGF5b3V0IiwidGhlbWUiLCJjcmVhdGVkQXQiLCJEYXRlIiwidG9JU09TdHJpbmciLCJ1cGRhdGVkQXQiLCJkZXNjcmlwdGlvbnMiLCJjcmVhdGVTZWN0aW9uIiwiY29sbGFwc2VkIiwiY3JlYXRlTGlzdCIsImRlZmF1bHRTZWN0aW9uIiwic2VjdGlvbnMiLCJzZWN0aW9uSWQiLCJ0YWdzIiwicHJpb3JpdHkiLCJwb3NpdGlvbiIsIngiLCJ5Iiwic2l6ZSIsIndpZHRoIiwiaGVpZ2h0Iiwic291cmNlSWQiLCJ0YXJnZXRJZCIsImFuaW1hdGVkIiwiTWF0aCIsInJhbmRvbSIsInRvU3RyaW5nIiwic3Vic3RyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/utils/tocModels.js\n"));

/***/ })

});