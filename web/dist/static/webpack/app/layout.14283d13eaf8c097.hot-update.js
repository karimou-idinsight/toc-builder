"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/layout",{

/***/ "(app-pages-browser)/./src/app/store/boardSlice.js":
/*!*************************************!*\
  !*** ./src/app/store/boardSlice.js ***!
  \*************************************/
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addEdge: function() { return /* binding */ addEdge; },\n/* harmony export */   addList: function() { return /* binding */ addList; },\n/* harmony export */   addNode: function() { return /* binding */ addNode; },\n/* harmony export */   addSection: function() { return /* binding */ addSection; },\n/* harmony export */   clearCausalPath: function() { return /* binding */ clearCausalPath; },\n/* harmony export */   deleteEdge: function() { return /* binding */ deleteEdge; },\n/* harmony export */   deleteList: function() { return /* binding */ deleteList; },\n/* harmony export */   deleteNode: function() { return /* binding */ deleteNode; },\n/* harmony export */   deleteSection: function() { return /* binding */ deleteSection; },\n/* harmony export */   initializeBoard: function() { return /* binding */ initializeBoard; },\n/* harmony export */   moveNode: function() { return /* binding */ moveNode; },\n/* harmony export */   reorderLists: function() { return /* binding */ reorderLists; },\n/* harmony export */   reorderNodes: function() { return /* binding */ reorderNodes; },\n/* harmony export */   reorderSections: function() { return /* binding */ reorderSections; },\n/* harmony export */   setActiveId: function() { return /* binding */ setActiveId; },\n/* harmony export */   setCausalPathFocalNode: function() { return /* binding */ setCausalPathFocalNode; },\n/* harmony export */   setCausalPathMode: function() { return /* binding */ setCausalPathMode; },\n/* harmony export */   setCausalPathNodes: function() { return /* binding */ setCausalPathNodes; },\n/* harmony export */   setDragType: function() { return /* binding */ setDragType; },\n/* harmony export */   setDraggableNodes: function() { return /* binding */ setDraggableNodes; },\n/* harmony export */   setLinkMode: function() { return /* binding */ setLinkMode; },\n/* harmony export */   setLinkSource: function() { return /* binding */ setLinkSource; },\n/* harmony export */   toggleNodeDraggable: function() { return /* binding */ toggleNodeDraggable; },\n/* harmony export */   updateBoard: function() { return /* binding */ updateBoard; },\n/* harmony export */   updateEdge: function() { return /* binding */ updateEdge; },\n/* harmony export */   updateList: function() { return /* binding */ updateList; },\n/* harmony export */   updateNode: function() { return /* binding */ updateNode; },\n/* harmony export */   updateSection: function() { return /* binding */ updateSection; }\n/* harmony export */ });\n/* harmony import */ var _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @reduxjs/toolkit */ \"(app-pages-browser)/./node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs\");\n/* harmony import */ var _utils_tocModels__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/tocModels */ \"(app-pages-browser)/./src/app/utils/tocModels.js\");\n\n\nconst initialState = {\n    board: null,\n    linkMode: false,\n    linkSource: null,\n    activeId: null,\n    dragType: null,\n    draggableNodes: [],\n    causalPathMode: false,\n    causalPathNodes: [],\n    causalPathFocalNode: null\n};\nconst boardSlice = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.createSlice)({\n    name: \"board\",\n    initialState,\n    reducers: {\n        // Initialize board\n        initializeBoard: (state, action)=>{\n            state.board = action.payload || (0,_utils_tocModels__WEBPACK_IMPORTED_MODULE_0__.createBoard)();\n        },\n        // Board operations\n        updateBoard: (state, action)=>{\n            if (state.board) {\n                state.board = {\n                    ...state.board,\n                    ...action.payload,\n                    updatedAt: new Date().toISOString()\n                };\n            }\n        },\n        // List operations\n        addList: (state, action)=>{\n            if (state.board) {\n                state.board.lists.push(action.payload);\n                state.board.updatedAt = new Date().toISOString();\n            }\n        },\n        updateList: (state, action)=>{\n            if (state.board) {\n                const { listId, updates } = action.payload;\n                const listIndex = state.board.lists.findIndex((list)=>list.id === listId);\n                if (listIndex !== -1) {\n                    state.board.lists[listIndex] = {\n                        ...state.board.lists[listIndex],\n                        ...updates\n                    };\n                    state.board.updatedAt = new Date().toISOString();\n                }\n            }\n        },\n        deleteList: (state, action)=>{\n            if (state.board) {\n                const listId = action.payload;\n                state.board.lists = state.board.lists.filter((list)=>list.id !== listId);\n                state.board.nodes = state.board.nodes.filter((node)=>node.listId !== listId);\n                state.board.updatedAt = new Date().toISOString();\n            }\n        },\n        reorderLists: (state, action)=>{\n            if (state.board) {\n                const { draggedId, targetId } = action.payload;\n                const lists = [\n                    ...state.board.lists\n                ];\n                const draggedIndex = lists.findIndex((list)=>list.id === draggedId);\n                const targetIndex = lists.findIndex((list)=>list.id === targetId);\n                if (draggedIndex !== -1 && targetIndex !== -1) {\n                    const [draggedList] = lists.splice(draggedIndex, 1);\n                    lists.splice(targetIndex, 0, draggedList);\n                    lists.forEach((list, index)=>{\n                        list.order = index;\n                    });\n                    state.board.lists = lists;\n                    state.board.updatedAt = new Date().toISOString();\n                }\n            }\n        },\n        // Section operations\n        addSection: (state, action)=>{\n            if (state.board) {\n                const { listId, section } = action.payload;\n                const list = state.board.lists.find((l)=>l.id === listId);\n                if (list) {\n                    if (!list.sections) {\n                        list.sections = [];\n                    }\n                    list.sections.push(section);\n                    state.board.updatedAt = new Date().toISOString();\n                }\n            }\n        },\n        updateSection: (state, action)=>{\n            if (state.board) {\n                const { listId, sectionId, updates } = action.payload;\n                const list = state.board.lists.find((l)=>l.id === listId);\n                if (list && list.sections) {\n                    const sectionIndex = list.sections.findIndex((s)=>s.id === sectionId);\n                    if (sectionIndex !== -1) {\n                        list.sections[sectionIndex] = {\n                            ...list.sections[sectionIndex],\n                            ...updates\n                        };\n                        state.board.updatedAt = new Date().toISOString();\n                    }\n                }\n            }\n        },\n        deleteSection: (state, action)=>{\n            if (state.board) {\n                const { listId, sectionId } = action.payload;\n                const list = state.board.lists.find((l)=>l.id === listId);\n                if (list && list.sections) {\n                    // Ensure at least one section remains\n                    if (list.sections.length <= 1) {\n                        return; // Cannot delete the last section\n                    }\n                    // Find the first remaining section (ungrouped section)\n                    const remainingSections = list.sections.filter((s)=>s.id !== sectionId);\n                    const firstSection = remainingSections[0];\n                    // Move all nodes from deleted section to the first remaining section\n                    if (state.board.nodes) {\n                        state.board.nodes.forEach((node)=>{\n                            if (node.sectionId === sectionId && node.listId === listId) {\n                                node.sectionId = firstSection.id;\n                            }\n                        });\n                    }\n                    // Remove the section\n                    list.sections = remainingSections;\n                    // Update section orders\n                    list.sections.forEach((section, index)=>{\n                        section.order = index;\n                    });\n                    state.board.updatedAt = new Date().toISOString();\n                }\n            }\n        },\n        reorderSections: (state, action)=>{\n            if (state.board) {\n                const { listId, draggedSectionId, targetSectionId } = action.payload;\n                const list = state.board.lists.find((l)=>l.id === listId);\n                if (list && list.sections) {\n                    const sections = [\n                        ...list.sections\n                    ];\n                    const draggedIndex = sections.findIndex((s)=>s.id === draggedSectionId);\n                    const targetIndex = sections.findIndex((s)=>s.id === targetSectionId);\n                    if (draggedIndex !== -1 && targetIndex !== -1) {\n                        const [draggedSection] = sections.splice(draggedIndex, 1);\n                        sections.splice(targetIndex, 0, draggedSection);\n                        sections.forEach((section, index)=>{\n                            section.order = index;\n                        });\n                        list.sections = sections;\n                        state.board.updatedAt = new Date().toISOString();\n                    }\n                }\n            }\n        },\n        // Node operations\n        addNode: (state, action)=>{\n            if (state.board) {\n                state.board.nodes.push(action.payload);\n                state.board.updatedAt = new Date().toISOString();\n            }\n        },\n        updateNode: (state, action)=>{\n            if (state.board) {\n                const { nodeId, updates } = action.payload;\n                const nodeIndex = state.board.nodes.findIndex((node)=>node.id === nodeId);\n                if (nodeIndex !== -1) {\n                    state.board.nodes[nodeIndex] = {\n                        ...state.board.nodes[nodeIndex],\n                        ...updates,\n                        updatedAt: new Date().toISOString()\n                    };\n                    state.board.updatedAt = new Date().toISOString();\n                }\n            }\n        },\n        deleteNode: (state, action)=>{\n            if (state.board) {\n                const nodeId = action.payload;\n                state.board.nodes = state.board.nodes.filter((node)=>node.id !== nodeId);\n                state.board.edges = state.board.edges.filter((edge)=>edge.sourceId !== nodeId && edge.targetId !== nodeId);\n                state.board.updatedAt = new Date().toISOString();\n            }\n        },\n        reorderNodes: (state, action)=>{\n            if (state.board) {\n                const { listId, draggedId, targetId } = action.payload;\n                const listNodes = state.board.nodes.filter((node)=>node.listId === listId);\n                const draggedIndex = listNodes.findIndex((node)=>node.id === draggedId);\n                const targetIndex = listNodes.findIndex((node)=>node.id === targetId);\n                if (draggedIndex !== -1 && targetIndex !== -1) {\n                    const [draggedNode] = listNodes.splice(draggedIndex, 1);\n                    listNodes.splice(targetIndex, 0, draggedNode);\n                    listNodes.forEach((node, index)=>{\n                        const nodeIndex = state.board.nodes.findIndex((n)=>n.id === node.id);\n                        if (nodeIndex !== -1) {\n                            state.board.nodes[nodeIndex].order = index;\n                        }\n                    });\n                    state.board.updatedAt = new Date().toISOString();\n                }\n            }\n        },\n        moveNode: (state, action)=>{\n            if (state.board) {\n                const { nodeId, targetListId } = action.payload;\n                const nodeIndex = state.board.nodes.findIndex((node)=>node.id === nodeId);\n                if (nodeIndex !== -1) {\n                    state.board.nodes[nodeIndex].listId = targetListId;\n                    const targetListNodes = state.board.nodes.filter((node)=>node.listId === targetListId);\n                    targetListNodes.forEach((node, index)=>{\n                        const nIndex = state.board.nodes.findIndex((n)=>n.id === node.id);\n                        if (nIndex !== -1) {\n                            state.board.nodes[nIndex].order = index;\n                        }\n                    });\n                    state.board.updatedAt = new Date().toISOString();\n                }\n            }\n        },\n        // Edge operations\n        addEdge: (state, action)=>{\n            if (state.board) {\n                state.board.edges.push(action.payload);\n                state.board.updatedAt = new Date().toISOString();\n            }\n        },\n        updateEdge: (state, action)=>{\n            if (state.board) {\n                const { edgeId, updates } = action.payload;\n                const edgeIndex = state.board.edges.findIndex((edge)=>edge.id === edgeId);\n                if (edgeIndex !== -1) {\n                    state.board.edges[edgeIndex] = {\n                        ...state.board.edges[edgeIndex],\n                        ...updates\n                    };\n                    state.board.updatedAt = new Date().toISOString();\n                }\n            }\n        },\n        deleteEdge: (state, action)=>{\n            if (state.board) {\n                const edgeId = action.payload;\n                state.board.edges = state.board.edges.filter((edge)=>edge.id !== edgeId);\n                state.board.updatedAt = new Date().toISOString();\n            }\n        },\n        // UI state\n        setLinkMode: (state, action)=>{\n            state.linkMode = action.payload;\n        },\n        setLinkSource: (state, action)=>{\n            state.linkSource = action.payload;\n        },\n        setActiveId: (state, action)=>{\n            state.activeId = action.payload;\n        },\n        setDragType: (state, action)=>{\n            state.dragType = action.payload;\n        },\n        setDraggableNodes: (state, action)=>{\n            state.draggableNodes = action.payload;\n        },\n        toggleNodeDraggable: (state, action)=>{\n            const { nodeId, isDraggable } = action.payload;\n            if (isDraggable) {\n                if (!state.draggableNodes.includes(nodeId)) {\n                    state.draggableNodes.push(nodeId);\n                }\n            } else {\n                state.draggableNodes = state.draggableNodes.filter((id)=>id !== nodeId);\n            }\n        },\n        setCausalPathMode: (state, action)=>{\n            state.causalPathMode = action.payload;\n        },\n        setCausalPathNodes: (state, action)=>{\n            state.causalPathNodes = action.payload;\n        },\n        setCausalPathFocalNode: (state, action)=>{\n            state.causalPathFocalNode = action.payload;\n        },\n        clearCausalPath: (state)=>{\n            state.causalPathNodes = [];\n            state.causalPathFocalNode = null;\n            state.causalPathMode = false;\n        }\n    }\n});\nconst { initializeBoard, updateBoard, addList, updateList, deleteList, reorderLists, addSection, updateSection, deleteSection, reorderSections, addNode, updateNode, deleteNode, reorderNodes, moveNode, addEdge, updateEdge, deleteEdge, setLinkMode, setLinkSource, setActiveId, setDragType, setDraggableNodes, toggleNodeDraggable, setCausalPathMode, setCausalPathNodes, setCausalPathFocalNode, clearCausalPath } = boardSlice.actions;\n/* harmony default export */ __webpack_exports__[\"default\"] = (boardSlice.reducer);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = __webpack_module__.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = __webpack_module__.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, __webpack_module__.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                __webpack_module__.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                __webpack_module__.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        __webpack_module__.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    __webpack_module__.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvc3RvcmUvYm9hcmRTbGljZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBK0M7QUFDRTtBQUVqRCxNQUFNRSxlQUFlO0lBQ25CQyxPQUFPO0lBQ1BDLFVBQVU7SUFDVkMsWUFBWTtJQUNaQyxVQUFVO0lBQ1ZDLFVBQVU7SUFDVkMsZ0JBQWdCLEVBQUU7SUFDbEJDLGdCQUFnQjtJQUNoQkMsaUJBQWlCLEVBQUU7SUFDbkJDLHFCQUFxQjtBQUN2QjtBQUVBLE1BQU1DLGFBQWFaLDZEQUFXQSxDQUFDO0lBQzdCYSxNQUFNO0lBQ05YO0lBQ0FZLFVBQVU7UUFDUixtQkFBbUI7UUFDbkJDLGlCQUFpQixDQUFDQyxPQUFPQztZQUN2QkQsTUFBTWIsS0FBSyxHQUFHYyxPQUFPQyxPQUFPLElBQUlqQiw2REFBV0E7UUFDN0M7UUFFQSxtQkFBbUI7UUFDbkJrQixhQUFhLENBQUNILE9BQU9DO1lBQ25CLElBQUlELE1BQU1iLEtBQUssRUFBRTtnQkFDZmEsTUFBTWIsS0FBSyxHQUFHO29CQUNaLEdBQUdhLE1BQU1iLEtBQUs7b0JBQ2QsR0FBR2MsT0FBT0MsT0FBTztvQkFDakJFLFdBQVcsSUFBSUMsT0FBT0MsV0FBVztnQkFDbkM7WUFDRjtRQUNGO1FBRUEsa0JBQWtCO1FBQ2xCQyxTQUFTLENBQUNQLE9BQU9DO1lBQ2YsSUFBSUQsTUFBTWIsS0FBSyxFQUFFO2dCQUNmYSxNQUFNYixLQUFLLENBQUNxQixLQUFLLENBQUNDLElBQUksQ0FBQ1IsT0FBT0MsT0FBTztnQkFDckNGLE1BQU1iLEtBQUssQ0FBQ2lCLFNBQVMsR0FBRyxJQUFJQyxPQUFPQyxXQUFXO1lBQ2hEO1FBQ0Y7UUFFQUksWUFBWSxDQUFDVixPQUFPQztZQUNsQixJQUFJRCxNQUFNYixLQUFLLEVBQUU7Z0JBQ2YsTUFBTSxFQUFFd0IsTUFBTSxFQUFFQyxPQUFPLEVBQUUsR0FBR1gsT0FBT0MsT0FBTztnQkFD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aUJBQWlCLENBQUNoRjtZQUNoQkEsTUFBTU4sZUFBZSxHQUFHLEVBQUU7WUFDMUJNLE1BQU1MLG1CQUFtQixHQUFHO1lBQzVCSyxNQUFNUCxjQUFjLEdBQUc7UUFDekI7SUFDRjtBQUNGO0FBRU8sTUFBTSxFQUNYTSxlQUFlLEVBQ2ZJLFdBQVcsRUFDWEksT0FBTyxFQUNQRyxVQUFVLEVBQ1ZPLFVBQVUsRUFDVkksWUFBWSxFQUNaVSxVQUFVLEVBQ1ZLLGFBQWEsRUFDYkksYUFBYSxFQUNiSSxlQUFlLEVBQ2ZJLE9BQU8sRUFDUEMsVUFBVSxFQUNWRyxVQUFVLEVBQ1ZJLFlBQVksRUFDWkksUUFBUSxFQUNSSSxPQUFPLEVBQ1BDLFVBQVUsRUFDVkcsVUFBVSxFQUNWQyxXQUFXLEVBQ1hDLGFBQWEsRUFDYkMsV0FBVyxFQUNYQyxXQUFXLEVBQ1hDLGlCQUFpQixFQUNqQkMsbUJBQW1CLEVBQ25CRyxpQkFBaUIsRUFDakJDLGtCQUFrQixFQUNsQkMsc0JBQXNCLEVBQ3RCQyxlQUFlLEVBQ2hCLEdBQUdwRixXQUFXcUYsT0FBTyxDQUFDO0FBRXZCLCtEQUFlckYsV0FBV3NGLE9BQU8sRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvYXBwL3N0b3JlL2JvYXJkU2xpY2UuanM/OWI4NiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVTbGljZSB9IGZyb20gJ0ByZWR1eGpzL3Rvb2xraXQnO1xuaW1wb3J0IHsgY3JlYXRlQm9hcmQgfSBmcm9tICcuLi91dGlscy90b2NNb2RlbHMnO1xuXG5jb25zdCBpbml0aWFsU3RhdGUgPSB7XG4gIGJvYXJkOiBudWxsLFxuICBsaW5rTW9kZTogZmFsc2UsXG4gIGxpbmtTb3VyY2U6IG51bGwsXG4gIGFjdGl2ZUlkOiBudWxsLFxuICBkcmFnVHlwZTogbnVsbCxcbiAgZHJhZ2dhYmxlTm9kZXM6IFtdLFxuICBjYXVzYWxQYXRoTW9kZTogZmFsc2UsXG4gIGNhdXNhbFBhdGhOb2RlczogW10sXG4gIGNhdXNhbFBhdGhGb2NhbE5vZGU6IG51bGwsXG59O1xuXG5jb25zdCBib2FyZFNsaWNlID0gY3JlYXRlU2xpY2Uoe1xuICBuYW1lOiAnYm9hcmQnLFxuICBpbml0aWFsU3RhdGUsXG4gIHJlZHVjZXJzOiB7XG4gICAgLy8gSW5pdGlhbGl6ZSBib2FyZFxuICAgIGluaXRpYWxpemVCb2FyZDogKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgICAgIHN0YXRlLmJvYXJkID0gYWN0aW9uLnBheWxvYWQgfHwgY3JlYXRlQm9hcmQoKTtcbiAgICB9LFxuXG4gICAgLy8gQm9hcmQgb3BlcmF0aW9uc1xuICAgIHVwZGF0ZUJvYXJkOiAoc3RhdGUsIGFjdGlvbikgPT4ge1xuICAgICAgaWYgKHN0YXRlLmJvYXJkKSB7XG4gICAgICAgIHN0YXRlLmJvYXJkID0ge1xuICAgICAgICAgIC4uLnN0YXRlLmJvYXJkLFxuICAgICAgICAgIC4uLmFjdGlvbi5wYXlsb2FkLFxuICAgICAgICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vIExpc3Qgb3BlcmF0aW9uc1xuICAgIGFkZExpc3Q6IChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gICAgICBpZiAoc3RhdGUuYm9hcmQpIHtcbiAgICAgICAgc3RhdGUuYm9hcmQubGlzdHMucHVzaChhY3Rpb24ucGF5bG9hZCk7XG4gICAgICAgIHN0YXRlLmJvYXJkLnVwZGF0ZWRBdCA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgdXBkYXRlTGlzdDogKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgICAgIGlmIChzdGF0ZS5ib2FyZCkge1xuICAgICAgICBjb25zdCB7IGxpc3RJZCwgdXBkYXRlcyB9ID0gYWN0aW9uLnBheWxvYWQ7XG4gICAgICAgIGNvbnN0IGxpc3RJbmRleCA9IHN0YXRlLmJvYXJkLmxpc3RzLmZpbmRJbmRleChsaXN0ID0+IGxpc3QuaWQgPT09IGxpc3RJZCk7XG4gICAgICAgIGlmIChsaXN0SW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgc3RhdGUuYm9hcmQubGlzdHNbbGlzdEluZGV4XSA9IHtcbiAgICAgICAgICAgIC4uLnN0YXRlLmJvYXJkLmxpc3RzW2xpc3RJbmRleF0sXG4gICAgICAgICAgICAuLi51cGRhdGVzXG4gICAgICAgICAgfTtcbiAgICAgICAgICBzdGF0ZS5ib2FyZC51cGRhdGVkQXQgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZGVsZXRlTGlzdDogKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgICAgIGlmIChzdGF0ZS5ib2FyZCkge1xuICAgICAgICBjb25zdCBsaXN0SWQgPSBhY3Rpb24ucGF5bG9hZDtcbiAgICAgICAgc3RhdGUuYm9hcmQubGlzdHMgPSBzdGF0ZS5ib2FyZC5saXN0cy5maWx0ZXIobGlzdCA9PiBsaXN0LmlkICE9PSBsaXN0SWQpO1xuICAgICAgICBzdGF0ZS5ib2FyZC5ub2RlcyA9IHN0YXRlLmJvYXJkLm5vZGVzLmZpbHRlcihub2RlID0+IG5vZGUubGlzdElkICE9PSBsaXN0SWQpO1xuICAgICAgICBzdGF0ZS5ib2FyZC51cGRhdGVkQXQgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHJlb3JkZXJMaXN0czogKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgICAgIGlmIChzdGF0ZS5ib2FyZCkge1xuICAgICAgICBjb25zdCB7IGRyYWdnZWRJZCwgdGFyZ2V0SWQgfSA9IGFjdGlvbi5wYXlsb2FkO1xuICAgICAgICBjb25zdCBsaXN0cyA9IFsuLi5zdGF0ZS5ib2FyZC5saXN0c107XG4gICAgICAgIGNvbnN0IGRyYWdnZWRJbmRleCA9IGxpc3RzLmZpbmRJbmRleChsaXN0ID0+IGxpc3QuaWQgPT09IGRyYWdnZWRJZCk7XG4gICAgICAgIGNvbnN0IHRhcmdldEluZGV4ID0gbGlzdHMuZmluZEluZGV4KGxpc3QgPT4gbGlzdC5pZCA9PT0gdGFyZ2V0SWQpO1xuICAgICAgICBcbiAgICAgICAgaWYgKGRyYWdnZWRJbmRleCAhPT0gLTEgJiYgdGFyZ2V0SW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgY29uc3QgW2RyYWdnZWRMaXN0XSA9IGxpc3RzLnNwbGljZShkcmFnZ2VkSW5kZXgsIDEpO1xuICAgICAgICAgIGxpc3RzLnNwbGljZSh0YXJnZXRJbmRleCwgMCwgZHJhZ2dlZExpc3QpO1xuICAgICAgICAgIFxuICAgICAgICAgIGxpc3RzLmZvckVhY2goKGxpc3QsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBsaXN0Lm9yZGVyID0gaW5kZXg7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgXG4gICAgICAgICAgc3RhdGUuYm9hcmQubGlzdHMgPSBsaXN0cztcbiAgICAgICAgICBzdGF0ZS5ib2FyZC51cGRhdGVkQXQgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gU2VjdGlvbiBvcGVyYXRpb25zXG4gICAgYWRkU2VjdGlvbjogKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgICAgIGlmIChzdGF0ZS5ib2FyZCkge1xuICAgICAgICBjb25zdCB7IGxpc3RJZCwgc2VjdGlvbiB9ID0gYWN0aW9uLnBheWxvYWQ7XG4gICAgICAgIGNvbnN0IGxpc3QgPSBzdGF0ZS5ib2FyZC5saXN0cy5maW5kKGwgPT4gbC5pZCA9PT0gbGlzdElkKTtcbiAgICAgICAgaWYgKGxpc3QpIHtcbiAgICAgICAgICBpZiAoIWxpc3Quc2VjdGlvbnMpIHtcbiAgICAgICAgICAgIGxpc3Quc2VjdGlvbnMgPSBbXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGlzdC5zZWN0aW9ucy5wdXNoKHNlY3Rpb24pO1xuICAgICAgICAgIHN0YXRlLmJvYXJkLnVwZGF0ZWRBdCA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICB1cGRhdGVTZWN0aW9uOiAoc3RhdGUsIGFjdGlvbikgPT4ge1xuICAgICAgaWYgKHN0YXRlLmJvYXJkKSB7XG4gICAgICAgIGNvbnN0IHsgbGlzdElkLCBzZWN0aW9uSWQsIHVwZGF0ZXMgfSA9IGFjdGlvbi5wYXlsb2FkO1xuICAgICAgICBjb25zdCBsaXN0ID0gc3RhdGUuYm9hcmQubGlzdHMuZmluZChsID0+IGwuaWQgPT09IGxpc3RJZCk7XG4gICAgICAgIGlmIChsaXN0ICYmIGxpc3Quc2VjdGlvbnMpIHtcbiAgICAgICAgICBjb25zdCBzZWN0aW9uSW5kZXggPSBsaXN0LnNlY3Rpb25zLmZpbmRJbmRleChzID0+IHMuaWQgPT09IHNlY3Rpb25JZCk7XG4gICAgICAgICAgaWYgKHNlY3Rpb25JbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgIGxpc3Quc2VjdGlvbnNbc2VjdGlvbkluZGV4XSA9IHtcbiAgICAgICAgICAgICAgLi4ubGlzdC5zZWN0aW9uc1tzZWN0aW9uSW5kZXhdLFxuICAgICAgICAgICAgICAuLi51cGRhdGVzXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgc3RhdGUuYm9hcmQudXBkYXRlZEF0ID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBkZWxldGVTZWN0aW9uOiAoc3RhdGUsIGFjdGlvbikgPT4ge1xuICAgICAgaWYgKHN0YXRlLmJvYXJkKSB7XG4gICAgICAgIGNvbnN0IHsgbGlzdElkLCBzZWN0aW9uSWQgfSA9IGFjdGlvbi5wYXlsb2FkO1xuICAgICAgICBjb25zdCBsaXN0ID0gc3RhdGUuYm9hcmQubGlzdHMuZmluZChsID0+IGwuaWQgPT09IGxpc3RJZCk7XG4gICAgICAgIGlmIChsaXN0ICYmIGxpc3Quc2VjdGlvbnMpIHtcbiAgICAgICAgICAvLyBFbnN1cmUgYXQgbGVhc3Qgb25lIHNlY3Rpb24gcmVtYWluc1xuICAgICAgICAgIGlmIChsaXN0LnNlY3Rpb25zLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgICAgICByZXR1cm47IC8vIENhbm5vdCBkZWxldGUgdGhlIGxhc3Qgc2VjdGlvblxuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBGaW5kIHRoZSBmaXJzdCByZW1haW5pbmcgc2VjdGlvbiAodW5ncm91cGVkIHNlY3Rpb24pXG4gICAgICAgICAgY29uc3QgcmVtYWluaW5nU2VjdGlvbnMgPSBsaXN0LnNlY3Rpb25zLmZpbHRlcihzID0+IHMuaWQgIT09IHNlY3Rpb25JZCk7XG4gICAgICAgICAgY29uc3QgZmlyc3RTZWN0aW9uID0gcmVtYWluaW5nU2VjdGlvbnNbMF07XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gTW92ZSBhbGwgbm9kZXMgZnJvbSBkZWxldGVkIHNlY3Rpb24gdG8gdGhlIGZpcnN0IHJlbWFpbmluZyBzZWN0aW9uXG4gICAgICAgICAgaWYgKHN0YXRlLmJvYXJkLm5vZGVzKSB7XG4gICAgICAgICAgICBzdGF0ZS5ib2FyZC5ub2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICAgICAgICBpZiAobm9kZS5zZWN0aW9uSWQgPT09IHNlY3Rpb25JZCAmJiBub2RlLmxpc3RJZCA9PT0gbGlzdElkKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5zZWN0aW9uSWQgPSBmaXJzdFNlY3Rpb24uaWQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBSZW1vdmUgdGhlIHNlY3Rpb25cbiAgICAgICAgICBsaXN0LnNlY3Rpb25zID0gcmVtYWluaW5nU2VjdGlvbnM7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gVXBkYXRlIHNlY3Rpb24gb3JkZXJzXG4gICAgICAgICAgbGlzdC5zZWN0aW9ucy5mb3JFYWNoKChzZWN0aW9uLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgc2VjdGlvbi5vcmRlciA9IGluZGV4O1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIFxuICAgICAgICAgIHN0YXRlLmJvYXJkLnVwZGF0ZWRBdCA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICByZW9yZGVyU2VjdGlvbnM6IChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gICAgICBpZiAoc3RhdGUuYm9hcmQpIHtcbiAgICAgICAgY29uc3QgeyBsaXN0SWQsIGRyYWdnZWRTZWN0aW9uSWQsIHRhcmdldFNlY3Rpb25JZCB9ID0gYWN0aW9uLnBheWxvYWQ7XG4gICAgICAgIGNvbnN0IGxpc3QgPSBzdGF0ZS5ib2FyZC5saXN0cy5maW5kKGwgPT4gbC5pZCA9PT0gbGlzdElkKTtcbiAgICAgICAgaWYgKGxpc3QgJiYgbGlzdC5zZWN0aW9ucykge1xuICAgICAgICAgIGNvbnN0IHNlY3Rpb25zID0gWy4uLmxpc3Quc2VjdGlvbnNdO1xuICAgICAgICAgIGNvbnN0IGRyYWdnZWRJbmRleCA9IHNlY3Rpb25zLmZpbmRJbmRleChzID0+IHMuaWQgPT09IGRyYWdnZWRTZWN0aW9uSWQpO1xuICAgICAgICAgIGNvbnN0IHRhcmdldEluZGV4ID0gc2VjdGlvbnMuZmluZEluZGV4KHMgPT4gcy5pZCA9PT0gdGFyZ2V0U2VjdGlvbklkKTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoZHJhZ2dlZEluZGV4ICE9PSAtMSAmJiB0YXJnZXRJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgIGNvbnN0IFtkcmFnZ2VkU2VjdGlvbl0gPSBzZWN0aW9ucy5zcGxpY2UoZHJhZ2dlZEluZGV4LCAxKTtcbiAgICAgICAgICAgIHNlY3Rpb25zLnNwbGljZSh0YXJnZXRJbmRleCwgMCwgZHJhZ2dlZFNlY3Rpb24pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBzZWN0aW9ucy5mb3JFYWNoKChzZWN0aW9uLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICBzZWN0aW9uLm9yZGVyID0gaW5kZXg7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgbGlzdC5zZWN0aW9ucyA9IHNlY3Rpb25zO1xuICAgICAgICAgICAgc3RhdGUuYm9hcmQudXBkYXRlZEF0ID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBOb2RlIG9wZXJhdGlvbnNcbiAgICBhZGROb2RlOiAoc3RhdGUsIGFjdGlvbikgPT4ge1xuICAgICAgaWYgKHN0YXRlLmJvYXJkKSB7XG4gICAgICAgIHN0YXRlLmJvYXJkLm5vZGVzLnB1c2goYWN0aW9uLnBheWxvYWQpO1xuICAgICAgICBzdGF0ZS5ib2FyZC51cGRhdGVkQXQgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHVwZGF0ZU5vZGU6IChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gICAgICBpZiAoc3RhdGUuYm9hcmQpIHtcbiAgICAgICAgY29uc3QgeyBub2RlSWQsIHVwZGF0ZXMgfSA9IGFjdGlvbi5wYXlsb2FkO1xuICAgICAgICBjb25zdCBub2RlSW5kZXggPSBzdGF0ZS5ib2FyZC5ub2Rlcy5maW5kSW5kZXgobm9kZSA9PiBub2RlLmlkID09PSBub2RlSWQpO1xuICAgICAgICBpZiAobm9kZUluZGV4ICE9PSAtMSkge1xuICAgICAgICAgIHN0YXRlLmJvYXJkLm5vZGVzW25vZGVJbmRleF0gPSB7XG4gICAgICAgICAgICAuLi5zdGF0ZS5ib2FyZC5ub2Rlc1tub2RlSW5kZXhdLFxuICAgICAgICAgICAgLi4udXBkYXRlcyxcbiAgICAgICAgICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICAgICAgfTtcbiAgICAgICAgICBzdGF0ZS5ib2FyZC51cGRhdGVkQXQgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZGVsZXRlTm9kZTogKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgICAgIGlmIChzdGF0ZS5ib2FyZCkge1xuICAgICAgICBjb25zdCBub2RlSWQgPSBhY3Rpb24ucGF5bG9hZDtcbiAgICAgICAgc3RhdGUuYm9hcmQubm9kZXMgPSBzdGF0ZS5ib2FyZC5ub2Rlcy5maWx0ZXIobm9kZSA9PiBub2RlLmlkICE9PSBub2RlSWQpO1xuICAgICAgICBzdGF0ZS5ib2FyZC5lZGdlcyA9IHN0YXRlLmJvYXJkLmVkZ2VzLmZpbHRlcihcbiAgICAgICAgICBlZGdlID0+IGVkZ2Uuc291cmNlSWQgIT09IG5vZGVJZCAmJiBlZGdlLnRhcmdldElkICE9PSBub2RlSWRcbiAgICAgICAgKTtcbiAgICAgICAgc3RhdGUuYm9hcmQudXBkYXRlZEF0ID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICByZW9yZGVyTm9kZXM6IChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gICAgICBpZiAoc3RhdGUuYm9hcmQpIHtcbiAgICAgICAgY29uc3QgeyBsaXN0SWQsIGRyYWdnZWRJZCwgdGFyZ2V0SWQgfSA9IGFjdGlvbi5wYXlsb2FkO1xuICAgICAgICBjb25zdCBsaXN0Tm9kZXMgPSBzdGF0ZS5ib2FyZC5ub2Rlcy5maWx0ZXIobm9kZSA9PiBub2RlLmxpc3RJZCA9PT0gbGlzdElkKTtcbiAgICAgICAgY29uc3QgZHJhZ2dlZEluZGV4ID0gbGlzdE5vZGVzLmZpbmRJbmRleChub2RlID0+IG5vZGUuaWQgPT09IGRyYWdnZWRJZCk7XG4gICAgICAgIGNvbnN0IHRhcmdldEluZGV4ID0gbGlzdE5vZGVzLmZpbmRJbmRleChub2RlID0+IG5vZGUuaWQgPT09IHRhcmdldElkKTtcbiAgICAgICAgXG4gICAgICAgIGlmIChkcmFnZ2VkSW5kZXggIT09IC0xICYmIHRhcmdldEluZGV4ICE9PSAtMSkge1xuICAgICAgICAgIGNvbnN0IFtkcmFnZ2VkTm9kZV0gPSBsaXN0Tm9kZXMuc3BsaWNlKGRyYWdnZWRJbmRleCwgMSk7XG4gICAgICAgICAgbGlzdE5vZGVzLnNwbGljZSh0YXJnZXRJbmRleCwgMCwgZHJhZ2dlZE5vZGUpO1xuICAgICAgICAgIFxuICAgICAgICAgIGxpc3ROb2Rlcy5mb3JFYWNoKChub2RlLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgbm9kZUluZGV4ID0gc3RhdGUuYm9hcmQubm9kZXMuZmluZEluZGV4KG4gPT4gbi5pZCA9PT0gbm9kZS5pZCk7XG4gICAgICAgICAgICBpZiAobm9kZUluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICBzdGF0ZS5ib2FyZC5ub2Rlc1tub2RlSW5kZXhdLm9yZGVyID0gaW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgXG4gICAgICAgICAgc3RhdGUuYm9hcmQudXBkYXRlZEF0ID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIG1vdmVOb2RlOiAoc3RhdGUsIGFjdGlvbikgPT4ge1xuICAgICAgaWYgKHN0YXRlLmJvYXJkKSB7XG4gICAgICAgIGNvbnN0IHsgbm9kZUlkLCB0YXJnZXRMaXN0SWQgfSA9IGFjdGlvbi5wYXlsb2FkO1xuICAgICAgICBjb25zdCBub2RlSW5kZXggPSBzdGF0ZS5ib2FyZC5ub2Rlcy5maW5kSW5kZXgobm9kZSA9PiBub2RlLmlkID09PSBub2RlSWQpO1xuICAgICAgICBcbiAgICAgICAgaWYgKG5vZGVJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICBzdGF0ZS5ib2FyZC5ub2Rlc1tub2RlSW5kZXhdLmxpc3RJZCA9IHRhcmdldExpc3RJZDtcbiAgICAgICAgICBcbiAgICAgICAgICBjb25zdCB0YXJnZXRMaXN0Tm9kZXMgPSBzdGF0ZS5ib2FyZC5ub2Rlcy5maWx0ZXIobm9kZSA9PiBub2RlLmxpc3RJZCA9PT0gdGFyZ2V0TGlzdElkKTtcbiAgICAgICAgICB0YXJnZXRMaXN0Tm9kZXMuZm9yRWFjaCgobm9kZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5JbmRleCA9IHN0YXRlLmJvYXJkLm5vZGVzLmZpbmRJbmRleChuID0+IG4uaWQgPT09IG5vZGUuaWQpO1xuICAgICAgICAgICAgaWYgKG5JbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgc3RhdGUuYm9hcmQubm9kZXNbbkluZGV4XS5vcmRlciA9IGluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIFxuICAgICAgICAgIHN0YXRlLmJvYXJkLnVwZGF0ZWRBdCA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBFZGdlIG9wZXJhdGlvbnNcbiAgICBhZGRFZGdlOiAoc3RhdGUsIGFjdGlvbikgPT4ge1xuICAgICAgaWYgKHN0YXRlLmJvYXJkKSB7XG4gICAgICAgIHN0YXRlLmJvYXJkLmVkZ2VzLnB1c2goYWN0aW9uLnBheWxvYWQpO1xuICAgICAgICBzdGF0ZS5ib2FyZC51cGRhdGVkQXQgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHVwZGF0ZUVkZ2U6IChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gICAgICBpZiAoc3RhdGUuYm9hcmQpIHtcbiAgICAgICAgY29uc3QgeyBlZGdlSWQsIHVwZGF0ZXMgfSA9IGFjdGlvbi5wYXlsb2FkO1xuICAgICAgICBjb25zdCBlZGdlSW5kZXggPSBzdGF0ZS5ib2FyZC5lZGdlcy5maW5kSW5kZXgoZWRnZSA9PiBlZGdlLmlkID09PSBlZGdlSWQpO1xuICAgICAgICBpZiAoZWRnZUluZGV4ICE9PSAtMSkge1xuICAgICAgICAgIHN0YXRlLmJvYXJkLmVkZ2VzW2VkZ2VJbmRleF0gPSB7XG4gICAgICAgICAgICAuLi5zdGF0ZS5ib2FyZC5lZGdlc1tlZGdlSW5kZXhdLFxuICAgICAgICAgICAgLi4udXBkYXRlc1xuICAgICAgICAgIH07XG4gICAgICAgICAgc3RhdGUuYm9hcmQudXBkYXRlZEF0ID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGRlbGV0ZUVkZ2U6IChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gICAgICBpZiAoc3RhdGUuYm9hcmQpIHtcbiAgICAgICAgY29uc3QgZWRnZUlkID0gYWN0aW9uLnBheWxvYWQ7XG4gICAgICAgIHN0YXRlLmJvYXJkLmVkZ2VzID0gc3RhdGUuYm9hcmQuZWRnZXMuZmlsdGVyKGVkZ2UgPT4gZWRnZS5pZCAhPT0gZWRnZUlkKTtcbiAgICAgICAgc3RhdGUuYm9hcmQudXBkYXRlZEF0ID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBVSSBzdGF0ZVxuICAgIHNldExpbmtNb2RlOiAoc3RhdGUsIGFjdGlvbikgPT4ge1xuICAgICAgc3RhdGUubGlua01vZGUgPSBhY3Rpb24ucGF5bG9hZDtcbiAgICB9LFxuXG4gICAgc2V0TGlua1NvdXJjZTogKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgICAgIHN0YXRlLmxpbmtTb3VyY2UgPSBhY3Rpb24ucGF5bG9hZDtcbiAgICB9LFxuXG4gICAgc2V0QWN0aXZlSWQ6IChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gICAgICBzdGF0ZS5hY3RpdmVJZCA9IGFjdGlvbi5wYXlsb2FkO1xuICAgIH0sXG5cbiAgICBzZXREcmFnVHlwZTogKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgICAgIHN0YXRlLmRyYWdUeXBlID0gYWN0aW9uLnBheWxvYWQ7XG4gICAgfSxcblxuICAgIHNldERyYWdnYWJsZU5vZGVzOiAoc3RhdGUsIGFjdGlvbikgPT4ge1xuICAgICAgc3RhdGUuZHJhZ2dhYmxlTm9kZXMgPSBhY3Rpb24ucGF5bG9hZDtcbiAgICB9LFxuXG4gICAgdG9nZ2xlTm9kZURyYWdnYWJsZTogKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgICAgIGNvbnN0IHsgbm9kZUlkLCBpc0RyYWdnYWJsZSB9ID0gYWN0aW9uLnBheWxvYWQ7XG4gICAgICBpZiAoaXNEcmFnZ2FibGUpIHtcbiAgICAgICAgaWYgKCFzdGF0ZS5kcmFnZ2FibGVOb2Rlcy5pbmNsdWRlcyhub2RlSWQpKSB7XG4gICAgICAgICAgc3RhdGUuZHJhZ2dhYmxlTm9kZXMucHVzaChub2RlSWQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5kcmFnZ2FibGVOb2RlcyA9IHN0YXRlLmRyYWdnYWJsZU5vZGVzLmZpbHRlcihpZCA9PiBpZCAhPT0gbm9kZUlkKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc2V0Q2F1c2FsUGF0aE1vZGU6IChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gICAgICBzdGF0ZS5jYXVzYWxQYXRoTW9kZSA9IGFjdGlvbi5wYXlsb2FkO1xuICAgIH0sXG5cbiAgICBzZXRDYXVzYWxQYXRoTm9kZXM6IChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gICAgICBzdGF0ZS5jYXVzYWxQYXRoTm9kZXMgPSBhY3Rpb24ucGF5bG9hZDtcbiAgICB9LFxuXG4gICAgc2V0Q2F1c2FsUGF0aEZvY2FsTm9kZTogKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgICAgIHN0YXRlLmNhdXNhbFBhdGhGb2NhbE5vZGUgPSBhY3Rpb24ucGF5bG9hZDtcbiAgICB9LFxuXG4gICAgY2xlYXJDYXVzYWxQYXRoOiAoc3RhdGUpID0+IHtcbiAgICAgIHN0YXRlLmNhdXNhbFBhdGhOb2RlcyA9IFtdO1xuICAgICAgc3RhdGUuY2F1c2FsUGF0aEZvY2FsTm9kZSA9IG51bGw7XG4gICAgICBzdGF0ZS5jYXVzYWxQYXRoTW9kZSA9IGZhbHNlO1xuICAgIH1cbiAgfVxufSk7XG5cbmV4cG9ydCBjb25zdCB7XG4gIGluaXRpYWxpemVCb2FyZCxcbiAgdXBkYXRlQm9hcmQsXG4gIGFkZExpc3QsXG4gIHVwZGF0ZUxpc3QsXG4gIGRlbGV0ZUxpc3QsXG4gIHJlb3JkZXJMaXN0cyxcbiAgYWRkU2VjdGlvbixcbiAgdXBkYXRlU2VjdGlvbixcbiAgZGVsZXRlU2VjdGlvbixcbiAgcmVvcmRlclNlY3Rpb25zLFxuICBhZGROb2RlLFxuICB1cGRhdGVOb2RlLFxuICBkZWxldGVOb2RlLFxuICByZW9yZGVyTm9kZXMsXG4gIG1vdmVOb2RlLFxuICBhZGRFZGdlLFxuICB1cGRhdGVFZGdlLFxuICBkZWxldGVFZGdlLFxuICBzZXRMaW5rTW9kZSxcbiAgc2V0TGlua1NvdXJjZSxcbiAgc2V0QWN0aXZlSWQsXG4gIHNldERyYWdUeXBlLFxuICBzZXREcmFnZ2FibGVOb2RlcyxcbiAgdG9nZ2xlTm9kZURyYWdnYWJsZSxcbiAgc2V0Q2F1c2FsUGF0aE1vZGUsXG4gIHNldENhdXNhbFBhdGhOb2RlcyxcbiAgc2V0Q2F1c2FsUGF0aEZvY2FsTm9kZSxcbiAgY2xlYXJDYXVzYWxQYXRoXG59ID0gYm9hcmRTbGljZS5hY3Rpb25zO1xuXG5leHBvcnQgZGVmYXVsdCBib2FyZFNsaWNlLnJlZHVjZXI7XG5cbiJdLCJuYW1lcyI6WyJjcmVhdGVTbGljZSIsImNyZWF0ZUJvYXJkIiwiaW5pdGlhbFN0YXRlIiwiYm9hcmQiLCJsaW5rTW9kZSIsImxpbmtTb3VyY2UiLCJhY3RpdmVJZCIsImRyYWdUeXBlIiwiZHJhZ2dhYmxlTm9kZXMiLCJjYXVzYWxQYXRoTW9kZSIsImNhdXNhbFBhdGhOb2RlcyIsImNhdXNhbFBhdGhGb2NhbE5vZGUiLCJib2FyZFNsaWNlIiwibmFtZSIsInJlZHVjZXJzIiwiaW5pdGlhbGl6ZUJvYXJkIiwic3RhdGUiLCJhY3Rpb24iLCJwYXlsb2FkIiwidXBkYXRlQm9hcmQiLCJ1cGRhdGVkQXQiLCJEYXRlIiwidG9JU09TdHJpbmciLCJhZGRMaXN0IiwibGlzdHMiLCJwdXNoIiwidXBkYXRlTGlzdCIsImxpc3RJZCIsInVwZGF0ZXMiLCJsaXN0SW5kZXgiLCJmaW5kSW5kZXgiLCJsaXN0IiwiaWQiLCJkZWxldGVMaXN0IiwiZmlsdGVyIiwibm9kZXMiLCJub2RlIiwicmVvcmRlckxpc3RzIiwiZHJhZ2dlZElkIiwidGFyZ2V0SWQiLCJkcmFnZ2VkSW5kZXgiLCJ0YXJnZXRJbmRleCIsImRyYWdnZWRMaXN0Iiwic3BsaWNlIiwiZm9yRWFjaCIsImluZGV4Iiwib3JkZXIiLCJhZGRTZWN0aW9uIiwic2VjdGlvbiIsImZpbmQiLCJsIiwic2VjdGlvbnMiLCJ1cGRhdGVTZWN0aW9uIiwic2VjdGlvbklkIiwic2VjdGlvbkluZGV4IiwicyIsImRlbGV0ZVNlY3Rpb24iLCJsZW5ndGgiLCJyZW1haW5pbmdTZWN0aW9ucyIsImZpcnN0U2VjdGlvbiIsInJlb3JkZXJTZWN0aW9ucyIsImRyYWdnZWRTZWN0aW9uSWQiLCJ0YXJnZXRTZWN0aW9uSWQiLCJkcmFnZ2VkU2VjdGlvbiIsImFkZE5vZGUiLCJ1cGRhdGVOb2RlIiwibm9kZUlkIiwibm9kZUluZGV4IiwiZGVsZXRlTm9kZSIsImVkZ2VzIiwiZWRnZSIsInNvdXJjZUlkIiwicmVvcmRlck5vZGVzIiwibGlzdE5vZGVzIiwiZHJhZ2dlZE5vZGUiLCJuIiwibW92ZU5vZGUiLCJ0YXJnZXRMaXN0SWQiLCJ0YXJnZXRMaXN0Tm9kZXMiLCJuSW5kZXgiLCJhZGRFZGdlIiwidXBkYXRlRWRnZSIsImVkZ2VJZCIsImVkZ2VJbmRleCIsImRlbGV0ZUVkZ2UiLCJzZXRMaW5rTW9kZSIsInNldExpbmtTb3VyY2UiLCJzZXRBY3RpdmVJZCIsInNldERyYWdUeXBlIiwic2V0RHJhZ2dhYmxlTm9kZXMiLCJ0b2dnbGVOb2RlRHJhZ2dhYmxlIiwiaXNEcmFnZ2FibGUiLCJpbmNsdWRlcyIsInNldENhdXNhbFBhdGhNb2RlIiwic2V0Q2F1c2FsUGF0aE5vZGVzIiwic2V0Q2F1c2FsUGF0aEZvY2FsTm9kZSIsImNsZWFyQ2F1c2FsUGF0aCIsImFjdGlvbnMiLCJyZWR1Y2VyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/store/boardSlice.js\n"));

/***/ })

});