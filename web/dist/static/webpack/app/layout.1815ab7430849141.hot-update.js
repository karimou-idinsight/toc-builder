"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/layout",{

/***/ "(app-pages-browser)/./src/app/store/boardSlice.js":
/*!*************************************!*\
  !*** ./src/app/store/boardSlice.js ***!
  \*************************************/
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addEdge: function() { return /* binding */ addEdge; },\n/* harmony export */   addList: function() { return /* binding */ addList; },\n/* harmony export */   addNode: function() { return /* binding */ addNode; },\n/* harmony export */   clearCausalPath: function() { return /* binding */ clearCausalPath; },\n/* harmony export */   deleteEdge: function() { return /* binding */ deleteEdge; },\n/* harmony export */   deleteList: function() { return /* binding */ deleteList; },\n/* harmony export */   deleteNode: function() { return /* binding */ deleteNode; },\n/* harmony export */   initializeBoard: function() { return /* binding */ initializeBoard; },\n/* harmony export */   moveNode: function() { return /* binding */ moveNode; },\n/* harmony export */   reorderLists: function() { return /* binding */ reorderLists; },\n/* harmony export */   reorderNodes: function() { return /* binding */ reorderNodes; },\n/* harmony export */   setActiveId: function() { return /* binding */ setActiveId; },\n/* harmony export */   setCausalPathFocalNode: function() { return /* binding */ setCausalPathFocalNode; },\n/* harmony export */   setCausalPathMode: function() { return /* binding */ setCausalPathMode; },\n/* harmony export */   setCausalPathNodes: function() { return /* binding */ setCausalPathNodes; },\n/* harmony export */   setDragType: function() { return /* binding */ setDragType; },\n/* harmony export */   setDraggableNodes: function() { return /* binding */ setDraggableNodes; },\n/* harmony export */   setLinkMode: function() { return /* binding */ setLinkMode; },\n/* harmony export */   setLinkSource: function() { return /* binding */ setLinkSource; },\n/* harmony export */   toggleNodeDraggable: function() { return /* binding */ toggleNodeDraggable; },\n/* harmony export */   updateBoard: function() { return /* binding */ updateBoard; },\n/* harmony export */   updateEdge: function() { return /* binding */ updateEdge; },\n/* harmony export */   updateList: function() { return /* binding */ updateList; },\n/* harmony export */   updateNode: function() { return /* binding */ updateNode; }\n/* harmony export */ });\n/* harmony import */ var _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @reduxjs/toolkit */ \"(app-pages-browser)/./node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs\");\n/* harmony import */ var _utils_tocModels__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/tocModels */ \"(app-pages-browser)/./src/app/utils/tocModels.js\");\n\n\nconst initialState = {\n    board: null,\n    linkMode: false,\n    linkSource: null,\n    activeId: null,\n    dragType: null,\n    draggableNodes: [],\n    causalPathMode: false,\n    causalPathNodes: [],\n    causalPathFocalNode: null\n};\nconst boardSlice = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.createSlice)({\n    name: \"board\",\n    initialState,\n    reducers: {\n        // Initialize board\n        initializeBoard: (state, action)=>{\n            state.board = action.payload || (0,_utils_tocModels__WEBPACK_IMPORTED_MODULE_0__.createBoard)();\n        },\n        // Board operations\n        updateBoard: (state, action)=>{\n            if (state.board) {\n                state.board = {\n                    ...state.board,\n                    ...action.payload,\n                    updatedAt: new Date().toISOString()\n                };\n            }\n        },\n        // List operations\n        addList: (state, action)=>{\n            if (state.board) {\n                state.board.lists.push(action.payload);\n                state.board.updatedAt = new Date().toISOString();\n            }\n        },\n        updateList: (state, action)=>{\n            if (state.board) {\n                const { listId, updates } = action.payload;\n                const listIndex = state.board.lists.findIndex((list)=>list.id === listId);\n                if (listIndex !== -1) {\n                    state.board.lists[listIndex] = {\n                        ...state.board.lists[listIndex],\n                        ...updates\n                    };\n                    state.board.updatedAt = new Date().toISOString();\n                }\n            }\n        },\n        deleteList: (state, action)=>{\n            if (state.board) {\n                const listId = action.payload;\n                state.board.lists = state.board.lists.filter((list)=>list.id !== listId);\n                state.board.nodes = state.board.nodes.filter((node)=>node.listId !== listId);\n                state.board.updatedAt = new Date().toISOString();\n            }\n        },\n        reorderLists: (state, action)=>{\n            if (state.board) {\n                const { draggedId, targetId } = action.payload;\n                const lists = [\n                    ...state.board.lists\n                ];\n                const draggedIndex = lists.findIndex((list)=>list.id === draggedId);\n                const targetIndex = lists.findIndex((list)=>list.id === targetId);\n                if (draggedIndex !== -1 && targetIndex !== -1) {\n                    const [draggedList] = lists.splice(draggedIndex, 1);\n                    lists.splice(targetIndex, 0, draggedList);\n                    lists.forEach((list, index)=>{\n                        list.order = index;\n                    });\n                    state.board.lists = lists;\n                    state.board.updatedAt = new Date().toISOString();\n                }\n            }\n        },\n        // Section operations\n        addSection: (state, action)=>{\n            if (state.board) {\n                const { listId, section } = action.payload;\n                const list = state.board.lists.find((l)=>l.id === listId);\n                if (list) {\n                    if (!list.sections) {\n                        list.sections = [];\n                    }\n                    list.sections.push(section);\n                    state.board.updatedAt = new Date().toISOString();\n                }\n            }\n        },\n        updateSection: (state, action)=>{\n            if (state.board) {\n                const { listId, sectionId, updates } = action.payload;\n                const list = state.board.lists.find((l)=>l.id === listId);\n                if (list && list.sections) {\n                    const sectionIndex = list.sections.findIndex((s)=>s.id === sectionId);\n                    if (sectionIndex !== -1) {\n                        list.sections[sectionIndex] = {\n                            ...list.sections[sectionIndex],\n                            ...updates\n                        };\n                        state.board.updatedAt = new Date().toISOString();\n                    }\n                }\n            }\n        },\n        deleteSection: (state, action)=>{\n            if (state.board) {\n                const { listId, sectionId } = action.payload;\n                const list = state.board.lists.find((l)=>l.id === listId);\n                if (list && list.sections) {\n                    // Ensure at least one section remains\n                    if (list.sections.length <= 1) {\n                        return; // Cannot delete the last section\n                    }\n                    // Find the first remaining section (ungrouped section)\n                    const remainingSections = list.sections.filter((s)=>s.id !== sectionId);\n                    const firstSection = remainingSections[0];\n                    // Move all nodes from deleted section to the first remaining section\n                    if (state.board.nodes) {\n                        state.board.nodes.forEach((node)=>{\n                            if (node.sectionId === sectionId && node.listId === listId) {\n                                node.sectionId = firstSection.id;\n                            }\n                        });\n                    }\n                    // Remove the section\n                    list.sections = remainingSections;\n                    // Update section orders\n                    list.sections.forEach((section, index)=>{\n                        section.order = index;\n                    });\n                    state.board.updatedAt = new Date().toISOString();\n                }\n            }\n        },\n        reorderSections: (state, action)=>{\n            if (state.board) {\n                const { listId, draggedSectionId, targetSectionId } = action.payload;\n                const list = state.board.lists.find((l)=>l.id === listId);\n                if (list && list.sections) {\n                    const sections = [\n                        ...list.sections\n                    ];\n                    const draggedIndex = sections.findIndex((s)=>s.id === draggedSectionId);\n                    const targetIndex = sections.findIndex((s)=>s.id === targetSectionId);\n                    if (draggedIndex !== -1 && targetIndex !== -1) {\n                        const [draggedSection] = sections.splice(draggedIndex, 1);\n                        sections.splice(targetIndex, 0, draggedSection);\n                        sections.forEach((section, index)=>{\n                            section.order = index;\n                        });\n                        list.sections = sections;\n                        state.board.updatedAt = new Date().toISOString();\n                    }\n                }\n            }\n        },\n        // Node operations\n        addNode: (state, action)=>{\n            if (state.board) {\n                state.board.nodes.push(action.payload);\n                state.board.updatedAt = new Date().toISOString();\n            }\n        },\n        updateNode: (state, action)=>{\n            if (state.board) {\n                const { nodeId, updates } = action.payload;\n                const nodeIndex = state.board.nodes.findIndex((node)=>node.id === nodeId);\n                if (nodeIndex !== -1) {\n                    state.board.nodes[nodeIndex] = {\n                        ...state.board.nodes[nodeIndex],\n                        ...updates,\n                        updatedAt: new Date().toISOString()\n                    };\n                    state.board.updatedAt = new Date().toISOString();\n                }\n            }\n        },\n        deleteNode: (state, action)=>{\n            if (state.board) {\n                const nodeId = action.payload;\n                state.board.nodes = state.board.nodes.filter((node)=>node.id !== nodeId);\n                state.board.edges = state.board.edges.filter((edge)=>edge.sourceId !== nodeId && edge.targetId !== nodeId);\n                state.board.updatedAt = new Date().toISOString();\n            }\n        },\n        reorderNodes: (state, action)=>{\n            if (state.board) {\n                const { listId, draggedId, targetId } = action.payload;\n                const listNodes = state.board.nodes.filter((node)=>node.listId === listId);\n                const draggedIndex = listNodes.findIndex((node)=>node.id === draggedId);\n                const targetIndex = listNodes.findIndex((node)=>node.id === targetId);\n                if (draggedIndex !== -1 && targetIndex !== -1) {\n                    const [draggedNode] = listNodes.splice(draggedIndex, 1);\n                    listNodes.splice(targetIndex, 0, draggedNode);\n                    listNodes.forEach((node, index)=>{\n                        const nodeIndex = state.board.nodes.findIndex((n)=>n.id === node.id);\n                        if (nodeIndex !== -1) {\n                            state.board.nodes[nodeIndex].order = index;\n                        }\n                    });\n                    state.board.updatedAt = new Date().toISOString();\n                }\n            }\n        },\n        moveNode: (state, action)=>{\n            if (state.board) {\n                const { nodeId, targetListId } = action.payload;\n                const nodeIndex = state.board.nodes.findIndex((node)=>node.id === nodeId);\n                if (nodeIndex !== -1) {\n                    state.board.nodes[nodeIndex].listId = targetListId;\n                    const targetListNodes = state.board.nodes.filter((node)=>node.listId === targetListId);\n                    targetListNodes.forEach((node, index)=>{\n                        const nIndex = state.board.nodes.findIndex((n)=>n.id === node.id);\n                        if (nIndex !== -1) {\n                            state.board.nodes[nIndex].order = index;\n                        }\n                    });\n                    state.board.updatedAt = new Date().toISOString();\n                }\n            }\n        },\n        // Edge operations\n        addEdge: (state, action)=>{\n            if (state.board) {\n                state.board.edges.push(action.payload);\n                state.board.updatedAt = new Date().toISOString();\n            }\n        },\n        updateEdge: (state, action)=>{\n            if (state.board) {\n                const { edgeId, updates } = action.payload;\n                const edgeIndex = state.board.edges.findIndex((edge)=>edge.id === edgeId);\n                if (edgeIndex !== -1) {\n                    state.board.edges[edgeIndex] = {\n                        ...state.board.edges[edgeIndex],\n                        ...updates\n                    };\n                    state.board.updatedAt = new Date().toISOString();\n                }\n            }\n        },\n        deleteEdge: (state, action)=>{\n            if (state.board) {\n                const edgeId = action.payload;\n                state.board.edges = state.board.edges.filter((edge)=>edge.id !== edgeId);\n                state.board.updatedAt = new Date().toISOString();\n            }\n        },\n        // UI state\n        setLinkMode: (state, action)=>{\n            state.linkMode = action.payload;\n        },\n        setLinkSource: (state, action)=>{\n            state.linkSource = action.payload;\n        },\n        setActiveId: (state, action)=>{\n            state.activeId = action.payload;\n        },\n        setDragType: (state, action)=>{\n            state.dragType = action.payload;\n        },\n        setDraggableNodes: (state, action)=>{\n            state.draggableNodes = action.payload;\n        },\n        toggleNodeDraggable: (state, action)=>{\n            const { nodeId, isDraggable } = action.payload;\n            if (isDraggable) {\n                if (!state.draggableNodes.includes(nodeId)) {\n                    state.draggableNodes.push(nodeId);\n                }\n            } else {\n                state.draggableNodes = state.draggableNodes.filter((id)=>id !== nodeId);\n            }\n        },\n        setCausalPathMode: (state, action)=>{\n            state.causalPathMode = action.payload;\n        },\n        setCausalPathNodes: (state, action)=>{\n            state.causalPathNodes = action.payload;\n        },\n        setCausalPathFocalNode: (state, action)=>{\n            state.causalPathFocalNode = action.payload;\n        },\n        clearCausalPath: (state)=>{\n            state.causalPathNodes = [];\n            state.causalPathFocalNode = null;\n            state.causalPathMode = false;\n        }\n    }\n});\nconst { initializeBoard, updateBoard, addList, updateList, deleteList, reorderLists, addNode, updateNode, deleteNode, reorderNodes, moveNode, addEdge, updateEdge, deleteEdge, setLinkMode, setLinkSource, setActiveId, setDragType, setDraggableNodes, toggleNodeDraggable, setCausalPathMode, setCausalPathNodes, setCausalPathFocalNode, clearCausalPath } = boardSlice.actions;\n/* harmony default export */ __webpack_exports__[\"default\"] = (boardSlice.reducer);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = __webpack_module__.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = __webpack_module__.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, __webpack_module__.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                __webpack_module__.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                __webpack_module__.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        __webpack_module__.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    __webpack_module__.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvc3RvcmUvYm9hcmRTbGljZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUErQztBQUNFO0FBRWpELE1BQU1FLGVBQWU7SUFDbkJDLE9BQU87SUFDUEMsVUFBVTtJQUNWQyxZQUFZO0lBQ1pDLFVBQVU7SUFDVkMsVUFBVTtJQUNWQyxnQkFBZ0IsRUFBRTtJQUNsQkMsZ0JBQWdCO0lBQ2hCQyxpQkFBaUIsRUFBRTtJQUNuQkMscUJBQXFCO0FBQ3ZCO0FBRUEsTUFBTUMsYUFBYVosNkRBQVdBLENBQUM7SUFDN0JhLE1BQU07SUFDTlg7SUFDQVksVUFBVTtRQUNSLG1CQUFtQjtRQUNuQkMsaUJBQWlCLENBQUNDLE9BQU9DO1lBQ3ZCRCxNQUFNYixLQUFLLEdBQUdjLE9BQU9DLE9BQU8sSUFBSWpCLDZEQUFXQTtRQUM3QztRQUVBLG1CQUFtQjtRQUNuQmtCLGFBQWEsQ0FBQ0gsT0FBT0M7WUFDbkIsSUFBSUQsTUFBTWIsS0FBSyxFQUFFO2dCQUNmYSxNQUFNYixLQUFLLEdBQUc7b0JBQ1osR0FBR2EsTUFBTWIsS0FBSztvQkFDZCxHQUFHYyxPQUFPQyxPQUFPO29CQUNqQkUsV0FBVyxJQUFJQyxPQUFPQyxXQUFXO2dCQUNuQztZQUNGO1FBQ0Y7UUFFQSxrQkFBa0I7UUFDbEJDLFNBQVMsQ0FBQ1AsT0FBT0M7WUFDZixJQUFJRCxNQUFNYixLQUFLLEVBQUU7Z0JBQ2ZhLE1BQU1iLEtBQUssQ0FBQ3FCLEtBQUssQ0FBQ0MsSUFBSSxDQUFDUixPQUFPQyxPQUFPO2dCQUNyQ0YsTUFBTWIsS0FBSyxDQUFDaUIsU0FBUyxHQUFHLElBQUlDLE9BQU9DLFdBQVc7WUFDaEQ7UUFDRjtRQUVBSSxZQUFZLENBQUNWLE9BQU9DO1lBQ2xCLElBQUlELE1BQU1iLEtBQUssRUFBRTtnQkFDZixNQUFNLEVBQUV3QixNQUFNLEVBQUVDLE9BQU8sRUFBRSxHQUFHWCxPQUFPQyxPQUFPO2dCQUMxQyxN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aUIsQ0FBQ2hGO1lBQ2hCQSxNQUFNTixlQUFlLEdBQUcsRUFBRTtZQUMxQk0sTUFBTUwsbUJBQW1CLEdBQUc7WUFDNUJLLE1BQU1QLGNBQWMsR0FBRztRQUN6QjtJQUNGO0FBQ0Y7QUFFTyxNQUFNLEVBQ1hNLGVBQWUsRUFDZkksV0FBVyxFQUNYSSxPQUFPLEVBQ1BHLFVBQVUsRUFDVk8sVUFBVSxFQUNWSSxZQUFZLEVBQ1oyQixPQUFPLEVBQ1BDLFVBQVUsRUFDVkcsVUFBVSxFQUNWSSxZQUFZLEVBQ1pJLFFBQVEsRUFDUkksT0FBTyxFQUNQQyxVQUFVLEVBQ1ZHLFVBQVUsRUFDVkMsV0FBVyxFQUNYQyxhQUFhLEVBQ2JDLFdBQVcsRUFDWEMsV0FBVyxFQUNYQyxpQkFBaUIsRUFDakJDLG1CQUFtQixFQUNuQkcsaUJBQWlCLEVBQ2pCQyxrQkFBa0IsRUFDbEJDLHNCQUFzQixFQUN0QkMsZUFBZSxFQUNoQixHQUFHcEYsV0FBV3FGLE9BQU8sQ0FBQztBQUV2QiwrREFBZXJGLFdBQVdzRixPQUFPLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2FwcC9zdG9yZS9ib2FyZFNsaWNlLmpzPzliODYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlU2xpY2UgfSBmcm9tICdAcmVkdXhqcy90b29sa2l0JztcbmltcG9ydCB7IGNyZWF0ZUJvYXJkIH0gZnJvbSAnLi4vdXRpbHMvdG9jTW9kZWxzJztcblxuY29uc3QgaW5pdGlhbFN0YXRlID0ge1xuICBib2FyZDogbnVsbCxcbiAgbGlua01vZGU6IGZhbHNlLFxuICBsaW5rU291cmNlOiBudWxsLFxuICBhY3RpdmVJZDogbnVsbCxcbiAgZHJhZ1R5cGU6IG51bGwsXG4gIGRyYWdnYWJsZU5vZGVzOiBbXSxcbiAgY2F1c2FsUGF0aE1vZGU6IGZhbHNlLFxuICBjYXVzYWxQYXRoTm9kZXM6IFtdLFxuICBjYXVzYWxQYXRoRm9jYWxOb2RlOiBudWxsLFxufTtcblxuY29uc3QgYm9hcmRTbGljZSA9IGNyZWF0ZVNsaWNlKHtcbiAgbmFtZTogJ2JvYXJkJyxcbiAgaW5pdGlhbFN0YXRlLFxuICByZWR1Y2Vyczoge1xuICAgIC8vIEluaXRpYWxpemUgYm9hcmRcbiAgICBpbml0aWFsaXplQm9hcmQ6IChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gICAgICBzdGF0ZS5ib2FyZCA9IGFjdGlvbi5wYXlsb2FkIHx8IGNyZWF0ZUJvYXJkKCk7XG4gICAgfSxcblxuICAgIC8vIEJvYXJkIG9wZXJhdGlvbnNcbiAgICB1cGRhdGVCb2FyZDogKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgICAgIGlmIChzdGF0ZS5ib2FyZCkge1xuICAgICAgICBzdGF0ZS5ib2FyZCA9IHtcbiAgICAgICAgICAuLi5zdGF0ZS5ib2FyZCxcbiAgICAgICAgICAuLi5hY3Rpb24ucGF5bG9hZCxcbiAgICAgICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBMaXN0IG9wZXJhdGlvbnNcbiAgICBhZGRMaXN0OiAoc3RhdGUsIGFjdGlvbikgPT4ge1xuICAgICAgaWYgKHN0YXRlLmJvYXJkKSB7XG4gICAgICAgIHN0YXRlLmJvYXJkLmxpc3RzLnB1c2goYWN0aW9uLnBheWxvYWQpO1xuICAgICAgICBzdGF0ZS5ib2FyZC51cGRhdGVkQXQgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHVwZGF0ZUxpc3Q6IChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gICAgICBpZiAoc3RhdGUuYm9hcmQpIHtcbiAgICAgICAgY29uc3QgeyBsaXN0SWQsIHVwZGF0ZXMgfSA9IGFjdGlvbi5wYXlsb2FkO1xuICAgICAgICBjb25zdCBsaXN0SW5kZXggPSBzdGF0ZS5ib2FyZC5saXN0cy5maW5kSW5kZXgobGlzdCA9PiBsaXN0LmlkID09PSBsaXN0SWQpO1xuICAgICAgICBpZiAobGlzdEluZGV4ICE9PSAtMSkge1xuICAgICAgICAgIHN0YXRlLmJvYXJkLmxpc3RzW2xpc3RJbmRleF0gPSB7XG4gICAgICAgICAgICAuLi5zdGF0ZS5ib2FyZC5saXN0c1tsaXN0SW5kZXhdLFxuICAgICAgICAgICAgLi4udXBkYXRlc1xuICAgICAgICAgIH07XG4gICAgICAgICAgc3RhdGUuYm9hcmQudXBkYXRlZEF0ID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGRlbGV0ZUxpc3Q6IChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gICAgICBpZiAoc3RhdGUuYm9hcmQpIHtcbiAgICAgICAgY29uc3QgbGlzdElkID0gYWN0aW9uLnBheWxvYWQ7XG4gICAgICAgIHN0YXRlLmJvYXJkLmxpc3RzID0gc3RhdGUuYm9hcmQubGlzdHMuZmlsdGVyKGxpc3QgPT4gbGlzdC5pZCAhPT0gbGlzdElkKTtcbiAgICAgICAgc3RhdGUuYm9hcmQubm9kZXMgPSBzdGF0ZS5ib2FyZC5ub2Rlcy5maWx0ZXIobm9kZSA9PiBub2RlLmxpc3RJZCAhPT0gbGlzdElkKTtcbiAgICAgICAgc3RhdGUuYm9hcmQudXBkYXRlZEF0ID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICByZW9yZGVyTGlzdHM6IChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gICAgICBpZiAoc3RhdGUuYm9hcmQpIHtcbiAgICAgICAgY29uc3QgeyBkcmFnZ2VkSWQsIHRhcmdldElkIH0gPSBhY3Rpb24ucGF5bG9hZDtcbiAgICAgICAgY29uc3QgbGlzdHMgPSBbLi4uc3RhdGUuYm9hcmQubGlzdHNdO1xuICAgICAgICBjb25zdCBkcmFnZ2VkSW5kZXggPSBsaXN0cy5maW5kSW5kZXgobGlzdCA9PiBsaXN0LmlkID09PSBkcmFnZ2VkSWQpO1xuICAgICAgICBjb25zdCB0YXJnZXRJbmRleCA9IGxpc3RzLmZpbmRJbmRleChsaXN0ID0+IGxpc3QuaWQgPT09IHRhcmdldElkKTtcbiAgICAgICAgXG4gICAgICAgIGlmIChkcmFnZ2VkSW5kZXggIT09IC0xICYmIHRhcmdldEluZGV4ICE9PSAtMSkge1xuICAgICAgICAgIGNvbnN0IFtkcmFnZ2VkTGlzdF0gPSBsaXN0cy5zcGxpY2UoZHJhZ2dlZEluZGV4LCAxKTtcbiAgICAgICAgICBsaXN0cy5zcGxpY2UodGFyZ2V0SW5kZXgsIDAsIGRyYWdnZWRMaXN0KTtcbiAgICAgICAgICBcbiAgICAgICAgICBsaXN0cy5mb3JFYWNoKChsaXN0LCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgbGlzdC5vcmRlciA9IGluZGV4O1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIFxuICAgICAgICAgIHN0YXRlLmJvYXJkLmxpc3RzID0gbGlzdHM7XG4gICAgICAgICAgc3RhdGUuYm9hcmQudXBkYXRlZEF0ID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vIFNlY3Rpb24gb3BlcmF0aW9uc1xuICAgIGFkZFNlY3Rpb246IChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gICAgICBpZiAoc3RhdGUuYm9hcmQpIHtcbiAgICAgICAgY29uc3QgeyBsaXN0SWQsIHNlY3Rpb24gfSA9IGFjdGlvbi5wYXlsb2FkO1xuICAgICAgICBjb25zdCBsaXN0ID0gc3RhdGUuYm9hcmQubGlzdHMuZmluZChsID0+IGwuaWQgPT09IGxpc3RJZCk7XG4gICAgICAgIGlmIChsaXN0KSB7XG4gICAgICAgICAgaWYgKCFsaXN0LnNlY3Rpb25zKSB7XG4gICAgICAgICAgICBsaXN0LnNlY3Rpb25zID0gW107XG4gICAgICAgICAgfVxuICAgICAgICAgIGxpc3Quc2VjdGlvbnMucHVzaChzZWN0aW9uKTtcbiAgICAgICAgICBzdGF0ZS5ib2FyZC51cGRhdGVkQXQgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgdXBkYXRlU2VjdGlvbjogKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgICAgIGlmIChzdGF0ZS5ib2FyZCkge1xuICAgICAgICBjb25zdCB7IGxpc3RJZCwgc2VjdGlvbklkLCB1cGRhdGVzIH0gPSBhY3Rpb24ucGF5bG9hZDtcbiAgICAgICAgY29uc3QgbGlzdCA9IHN0YXRlLmJvYXJkLmxpc3RzLmZpbmQobCA9PiBsLmlkID09PSBsaXN0SWQpO1xuICAgICAgICBpZiAobGlzdCAmJiBsaXN0LnNlY3Rpb25zKSB7XG4gICAgICAgICAgY29uc3Qgc2VjdGlvbkluZGV4ID0gbGlzdC5zZWN0aW9ucy5maW5kSW5kZXgocyA9PiBzLmlkID09PSBzZWN0aW9uSWQpO1xuICAgICAgICAgIGlmIChzZWN0aW9uSW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICBsaXN0LnNlY3Rpb25zW3NlY3Rpb25JbmRleF0gPSB7XG4gICAgICAgICAgICAgIC4uLmxpc3Quc2VjdGlvbnNbc2VjdGlvbkluZGV4XSxcbiAgICAgICAgICAgICAgLi4udXBkYXRlc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHN0YXRlLmJvYXJkLnVwZGF0ZWRBdCA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZGVsZXRlU2VjdGlvbjogKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgICAgIGlmIChzdGF0ZS5ib2FyZCkge1xuICAgICAgICBjb25zdCB7IGxpc3RJZCwgc2VjdGlvbklkIH0gPSBhY3Rpb24ucGF5bG9hZDtcbiAgICAgICAgY29uc3QgbGlzdCA9IHN0YXRlLmJvYXJkLmxpc3RzLmZpbmQobCA9PiBsLmlkID09PSBsaXN0SWQpO1xuICAgICAgICBpZiAobGlzdCAmJiBsaXN0LnNlY3Rpb25zKSB7XG4gICAgICAgICAgLy8gRW5zdXJlIGF0IGxlYXN0IG9uZSBzZWN0aW9uIHJlbWFpbnNcbiAgICAgICAgICBpZiAobGlzdC5zZWN0aW9ucy5sZW5ndGggPD0gMSkge1xuICAgICAgICAgICAgcmV0dXJuOyAvLyBDYW5ub3QgZGVsZXRlIHRoZSBsYXN0IHNlY3Rpb25cbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gRmluZCB0aGUgZmlyc3QgcmVtYWluaW5nIHNlY3Rpb24gKHVuZ3JvdXBlZCBzZWN0aW9uKVxuICAgICAgICAgIGNvbnN0IHJlbWFpbmluZ1NlY3Rpb25zID0gbGlzdC5zZWN0aW9ucy5maWx0ZXIocyA9PiBzLmlkICE9PSBzZWN0aW9uSWQpO1xuICAgICAgICAgIGNvbnN0IGZpcnN0U2VjdGlvbiA9IHJlbWFpbmluZ1NlY3Rpb25zWzBdO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIE1vdmUgYWxsIG5vZGVzIGZyb20gZGVsZXRlZCBzZWN0aW9uIHRvIHRoZSBmaXJzdCByZW1haW5pbmcgc2VjdGlvblxuICAgICAgICAgIGlmIChzdGF0ZS5ib2FyZC5ub2Rlcykge1xuICAgICAgICAgICAgc3RhdGUuYm9hcmQubm9kZXMuZm9yRWFjaChub2RlID0+IHtcbiAgICAgICAgICAgICAgaWYgKG5vZGUuc2VjdGlvbklkID09PSBzZWN0aW9uSWQgJiYgbm9kZS5saXN0SWQgPT09IGxpc3RJZCkge1xuICAgICAgICAgICAgICAgIG5vZGUuc2VjdGlvbklkID0gZmlyc3RTZWN0aW9uLmlkO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gUmVtb3ZlIHRoZSBzZWN0aW9uXG4gICAgICAgICAgbGlzdC5zZWN0aW9ucyA9IHJlbWFpbmluZ1NlY3Rpb25zO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFVwZGF0ZSBzZWN0aW9uIG9yZGVyc1xuICAgICAgICAgIGxpc3Quc2VjdGlvbnMuZm9yRWFjaCgoc2VjdGlvbiwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIHNlY3Rpb24ub3JkZXIgPSBpbmRleDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBcbiAgICAgICAgICBzdGF0ZS5ib2FyZC51cGRhdGVkQXQgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVvcmRlclNlY3Rpb25zOiAoc3RhdGUsIGFjdGlvbikgPT4ge1xuICAgICAgaWYgKHN0YXRlLmJvYXJkKSB7XG4gICAgICAgIGNvbnN0IHsgbGlzdElkLCBkcmFnZ2VkU2VjdGlvbklkLCB0YXJnZXRTZWN0aW9uSWQgfSA9IGFjdGlvbi5wYXlsb2FkO1xuICAgICAgICBjb25zdCBsaXN0ID0gc3RhdGUuYm9hcmQubGlzdHMuZmluZChsID0+IGwuaWQgPT09IGxpc3RJZCk7XG4gICAgICAgIGlmIChsaXN0ICYmIGxpc3Quc2VjdGlvbnMpIHtcbiAgICAgICAgICBjb25zdCBzZWN0aW9ucyA9IFsuLi5saXN0LnNlY3Rpb25zXTtcbiAgICAgICAgICBjb25zdCBkcmFnZ2VkSW5kZXggPSBzZWN0aW9ucy5maW5kSW5kZXgocyA9PiBzLmlkID09PSBkcmFnZ2VkU2VjdGlvbklkKTtcbiAgICAgICAgICBjb25zdCB0YXJnZXRJbmRleCA9IHNlY3Rpb25zLmZpbmRJbmRleChzID0+IHMuaWQgPT09IHRhcmdldFNlY3Rpb25JZCk7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKGRyYWdnZWRJbmRleCAhPT0gLTEgJiYgdGFyZ2V0SW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICBjb25zdCBbZHJhZ2dlZFNlY3Rpb25dID0gc2VjdGlvbnMuc3BsaWNlKGRyYWdnZWRJbmRleCwgMSk7XG4gICAgICAgICAgICBzZWN0aW9ucy5zcGxpY2UodGFyZ2V0SW5kZXgsIDAsIGRyYWdnZWRTZWN0aW9uKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgc2VjdGlvbnMuZm9yRWFjaCgoc2VjdGlvbiwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgc2VjdGlvbi5vcmRlciA9IGluZGV4O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGxpc3Quc2VjdGlvbnMgPSBzZWN0aW9ucztcbiAgICAgICAgICAgIHN0YXRlLmJvYXJkLnVwZGF0ZWRBdCA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gTm9kZSBvcGVyYXRpb25zXG4gICAgYWRkTm9kZTogKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgICAgIGlmIChzdGF0ZS5ib2FyZCkge1xuICAgICAgICBzdGF0ZS5ib2FyZC5ub2Rlcy5wdXNoKGFjdGlvbi5wYXlsb2FkKTtcbiAgICAgICAgc3RhdGUuYm9hcmQudXBkYXRlZEF0ID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICB1cGRhdGVOb2RlOiAoc3RhdGUsIGFjdGlvbikgPT4ge1xuICAgICAgaWYgKHN0YXRlLmJvYXJkKSB7XG4gICAgICAgIGNvbnN0IHsgbm9kZUlkLCB1cGRhdGVzIH0gPSBhY3Rpb24ucGF5bG9hZDtcbiAgICAgICAgY29uc3Qgbm9kZUluZGV4ID0gc3RhdGUuYm9hcmQubm9kZXMuZmluZEluZGV4KG5vZGUgPT4gbm9kZS5pZCA9PT0gbm9kZUlkKTtcbiAgICAgICAgaWYgKG5vZGVJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICBzdGF0ZS5ib2FyZC5ub2Rlc1tub2RlSW5kZXhdID0ge1xuICAgICAgICAgICAgLi4uc3RhdGUuYm9hcmQubm9kZXNbbm9kZUluZGV4XSxcbiAgICAgICAgICAgIC4uLnVwZGF0ZXMsXG4gICAgICAgICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgICAgIH07XG4gICAgICAgICAgc3RhdGUuYm9hcmQudXBkYXRlZEF0ID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGRlbGV0ZU5vZGU6IChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gICAgICBpZiAoc3RhdGUuYm9hcmQpIHtcbiAgICAgICAgY29uc3Qgbm9kZUlkID0gYWN0aW9uLnBheWxvYWQ7XG4gICAgICAgIHN0YXRlLmJvYXJkLm5vZGVzID0gc3RhdGUuYm9hcmQubm9kZXMuZmlsdGVyKG5vZGUgPT4gbm9kZS5pZCAhPT0gbm9kZUlkKTtcbiAgICAgICAgc3RhdGUuYm9hcmQuZWRnZXMgPSBzdGF0ZS5ib2FyZC5lZGdlcy5maWx0ZXIoXG4gICAgICAgICAgZWRnZSA9PiBlZGdlLnNvdXJjZUlkICE9PSBub2RlSWQgJiYgZWRnZS50YXJnZXRJZCAhPT0gbm9kZUlkXG4gICAgICAgICk7XG4gICAgICAgIHN0YXRlLmJvYXJkLnVwZGF0ZWRBdCA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVvcmRlck5vZGVzOiAoc3RhdGUsIGFjdGlvbikgPT4ge1xuICAgICAgaWYgKHN0YXRlLmJvYXJkKSB7XG4gICAgICAgIGNvbnN0IHsgbGlzdElkLCBkcmFnZ2VkSWQsIHRhcmdldElkIH0gPSBhY3Rpb24ucGF5bG9hZDtcbiAgICAgICAgY29uc3QgbGlzdE5vZGVzID0gc3RhdGUuYm9hcmQubm9kZXMuZmlsdGVyKG5vZGUgPT4gbm9kZS5saXN0SWQgPT09IGxpc3RJZCk7XG4gICAgICAgIGNvbnN0IGRyYWdnZWRJbmRleCA9IGxpc3ROb2Rlcy5maW5kSW5kZXgobm9kZSA9PiBub2RlLmlkID09PSBkcmFnZ2VkSWQpO1xuICAgICAgICBjb25zdCB0YXJnZXRJbmRleCA9IGxpc3ROb2Rlcy5maW5kSW5kZXgobm9kZSA9PiBub2RlLmlkID09PSB0YXJnZXRJZCk7XG4gICAgICAgIFxuICAgICAgICBpZiAoZHJhZ2dlZEluZGV4ICE9PSAtMSAmJiB0YXJnZXRJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICBjb25zdCBbZHJhZ2dlZE5vZGVdID0gbGlzdE5vZGVzLnNwbGljZShkcmFnZ2VkSW5kZXgsIDEpO1xuICAgICAgICAgIGxpc3ROb2Rlcy5zcGxpY2UodGFyZ2V0SW5kZXgsIDAsIGRyYWdnZWROb2RlKTtcbiAgICAgICAgICBcbiAgICAgICAgICBsaXN0Tm9kZXMuZm9yRWFjaCgobm9kZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGVJbmRleCA9IHN0YXRlLmJvYXJkLm5vZGVzLmZpbmRJbmRleChuID0+IG4uaWQgPT09IG5vZGUuaWQpO1xuICAgICAgICAgICAgaWYgKG5vZGVJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgc3RhdGUuYm9hcmQubm9kZXNbbm9kZUluZGV4XS5vcmRlciA9IGluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIFxuICAgICAgICAgIHN0YXRlLmJvYXJkLnVwZGF0ZWRBdCA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBtb3ZlTm9kZTogKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgICAgIGlmIChzdGF0ZS5ib2FyZCkge1xuICAgICAgICBjb25zdCB7IG5vZGVJZCwgdGFyZ2V0TGlzdElkIH0gPSBhY3Rpb24ucGF5bG9hZDtcbiAgICAgICAgY29uc3Qgbm9kZUluZGV4ID0gc3RhdGUuYm9hcmQubm9kZXMuZmluZEluZGV4KG5vZGUgPT4gbm9kZS5pZCA9PT0gbm9kZUlkKTtcbiAgICAgICAgXG4gICAgICAgIGlmIChub2RlSW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgc3RhdGUuYm9hcmQubm9kZXNbbm9kZUluZGV4XS5saXN0SWQgPSB0YXJnZXRMaXN0SWQ7XG4gICAgICAgICAgXG4gICAgICAgICAgY29uc3QgdGFyZ2V0TGlzdE5vZGVzID0gc3RhdGUuYm9hcmQubm9kZXMuZmlsdGVyKG5vZGUgPT4gbm9kZS5saXN0SWQgPT09IHRhcmdldExpc3RJZCk7XG4gICAgICAgICAgdGFyZ2V0TGlzdE5vZGVzLmZvckVhY2goKG5vZGUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuSW5kZXggPSBzdGF0ZS5ib2FyZC5ub2Rlcy5maW5kSW5kZXgobiA9PiBuLmlkID09PSBub2RlLmlkKTtcbiAgICAgICAgICAgIGlmIChuSW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgIHN0YXRlLmJvYXJkLm5vZGVzW25JbmRleF0ub3JkZXIgPSBpbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBcbiAgICAgICAgICBzdGF0ZS5ib2FyZC51cGRhdGVkQXQgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gRWRnZSBvcGVyYXRpb25zXG4gICAgYWRkRWRnZTogKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgICAgIGlmIChzdGF0ZS5ib2FyZCkge1xuICAgICAgICBzdGF0ZS5ib2FyZC5lZGdlcy5wdXNoKGFjdGlvbi5wYXlsb2FkKTtcbiAgICAgICAgc3RhdGUuYm9hcmQudXBkYXRlZEF0ID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICB1cGRhdGVFZGdlOiAoc3RhdGUsIGFjdGlvbikgPT4ge1xuICAgICAgaWYgKHN0YXRlLmJvYXJkKSB7XG4gICAgICAgIGNvbnN0IHsgZWRnZUlkLCB1cGRhdGVzIH0gPSBhY3Rpb24ucGF5bG9hZDtcbiAgICAgICAgY29uc3QgZWRnZUluZGV4ID0gc3RhdGUuYm9hcmQuZWRnZXMuZmluZEluZGV4KGVkZ2UgPT4gZWRnZS5pZCA9PT0gZWRnZUlkKTtcbiAgICAgICAgaWYgKGVkZ2VJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICBzdGF0ZS5ib2FyZC5lZGdlc1tlZGdlSW5kZXhdID0ge1xuICAgICAgICAgICAgLi4uc3RhdGUuYm9hcmQuZWRnZXNbZWRnZUluZGV4XSxcbiAgICAgICAgICAgIC4uLnVwZGF0ZXNcbiAgICAgICAgICB9O1xuICAgICAgICAgIHN0YXRlLmJvYXJkLnVwZGF0ZWRBdCA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBkZWxldGVFZGdlOiAoc3RhdGUsIGFjdGlvbikgPT4ge1xuICAgICAgaWYgKHN0YXRlLmJvYXJkKSB7XG4gICAgICAgIGNvbnN0IGVkZ2VJZCA9IGFjdGlvbi5wYXlsb2FkO1xuICAgICAgICBzdGF0ZS5ib2FyZC5lZGdlcyA9IHN0YXRlLmJvYXJkLmVkZ2VzLmZpbHRlcihlZGdlID0+IGVkZ2UuaWQgIT09IGVkZ2VJZCk7XG4gICAgICAgIHN0YXRlLmJvYXJkLnVwZGF0ZWRBdCA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gVUkgc3RhdGVcbiAgICBzZXRMaW5rTW9kZTogKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgICAgIHN0YXRlLmxpbmtNb2RlID0gYWN0aW9uLnBheWxvYWQ7XG4gICAgfSxcblxuICAgIHNldExpbmtTb3VyY2U6IChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gICAgICBzdGF0ZS5saW5rU291cmNlID0gYWN0aW9uLnBheWxvYWQ7XG4gICAgfSxcblxuICAgIHNldEFjdGl2ZUlkOiAoc3RhdGUsIGFjdGlvbikgPT4ge1xuICAgICAgc3RhdGUuYWN0aXZlSWQgPSBhY3Rpb24ucGF5bG9hZDtcbiAgICB9LFxuXG4gICAgc2V0RHJhZ1R5cGU6IChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gICAgICBzdGF0ZS5kcmFnVHlwZSA9IGFjdGlvbi5wYXlsb2FkO1xuICAgIH0sXG5cbiAgICBzZXREcmFnZ2FibGVOb2RlczogKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgICAgIHN0YXRlLmRyYWdnYWJsZU5vZGVzID0gYWN0aW9uLnBheWxvYWQ7XG4gICAgfSxcblxuICAgIHRvZ2dsZU5vZGVEcmFnZ2FibGU6IChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gICAgICBjb25zdCB7IG5vZGVJZCwgaXNEcmFnZ2FibGUgfSA9IGFjdGlvbi5wYXlsb2FkO1xuICAgICAgaWYgKGlzRHJhZ2dhYmxlKSB7XG4gICAgICAgIGlmICghc3RhdGUuZHJhZ2dhYmxlTm9kZXMuaW5jbHVkZXMobm9kZUlkKSkge1xuICAgICAgICAgIHN0YXRlLmRyYWdnYWJsZU5vZGVzLnB1c2gobm9kZUlkKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUuZHJhZ2dhYmxlTm9kZXMgPSBzdGF0ZS5kcmFnZ2FibGVOb2Rlcy5maWx0ZXIoaWQgPT4gaWQgIT09IG5vZGVJZCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHNldENhdXNhbFBhdGhNb2RlOiAoc3RhdGUsIGFjdGlvbikgPT4ge1xuICAgICAgc3RhdGUuY2F1c2FsUGF0aE1vZGUgPSBhY3Rpb24ucGF5bG9hZDtcbiAgICB9LFxuXG4gICAgc2V0Q2F1c2FsUGF0aE5vZGVzOiAoc3RhdGUsIGFjdGlvbikgPT4ge1xuICAgICAgc3RhdGUuY2F1c2FsUGF0aE5vZGVzID0gYWN0aW9uLnBheWxvYWQ7XG4gICAgfSxcblxuICAgIHNldENhdXNhbFBhdGhGb2NhbE5vZGU6IChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gICAgICBzdGF0ZS5jYXVzYWxQYXRoRm9jYWxOb2RlID0gYWN0aW9uLnBheWxvYWQ7XG4gICAgfSxcblxuICAgIGNsZWFyQ2F1c2FsUGF0aDogKHN0YXRlKSA9PiB7XG4gICAgICBzdGF0ZS5jYXVzYWxQYXRoTm9kZXMgPSBbXTtcbiAgICAgIHN0YXRlLmNhdXNhbFBhdGhGb2NhbE5vZGUgPSBudWxsO1xuICAgICAgc3RhdGUuY2F1c2FsUGF0aE1vZGUgPSBmYWxzZTtcbiAgICB9XG4gIH1cbn0pO1xuXG5leHBvcnQgY29uc3Qge1xuICBpbml0aWFsaXplQm9hcmQsXG4gIHVwZGF0ZUJvYXJkLFxuICBhZGRMaXN0LFxuICB1cGRhdGVMaXN0LFxuICBkZWxldGVMaXN0LFxuICByZW9yZGVyTGlzdHMsXG4gIGFkZE5vZGUsXG4gIHVwZGF0ZU5vZGUsXG4gIGRlbGV0ZU5vZGUsXG4gIHJlb3JkZXJOb2RlcyxcbiAgbW92ZU5vZGUsXG4gIGFkZEVkZ2UsXG4gIHVwZGF0ZUVkZ2UsXG4gIGRlbGV0ZUVkZ2UsXG4gIHNldExpbmtNb2RlLFxuICBzZXRMaW5rU291cmNlLFxuICBzZXRBY3RpdmVJZCxcbiAgc2V0RHJhZ1R5cGUsXG4gIHNldERyYWdnYWJsZU5vZGVzLFxuICB0b2dnbGVOb2RlRHJhZ2dhYmxlLFxuICBzZXRDYXVzYWxQYXRoTW9kZSxcbiAgc2V0Q2F1c2FsUGF0aE5vZGVzLFxuICBzZXRDYXVzYWxQYXRoRm9jYWxOb2RlLFxuICBjbGVhckNhdXNhbFBhdGhcbn0gPSBib2FyZFNsaWNlLmFjdGlvbnM7XG5cbmV4cG9ydCBkZWZhdWx0IGJvYXJkU2xpY2UucmVkdWNlcjtcblxuIl0sIm5hbWVzIjpbImNyZWF0ZVNsaWNlIiwiY3JlYXRlQm9hcmQiLCJpbml0aWFsU3RhdGUiLCJib2FyZCIsImxpbmtNb2RlIiwibGlua1NvdXJjZSIsImFjdGl2ZUlkIiwiZHJhZ1R5cGUiLCJkcmFnZ2FibGVOb2RlcyIsImNhdXNhbFBhdGhNb2RlIiwiY2F1c2FsUGF0aE5vZGVzIiwiY2F1c2FsUGF0aEZvY2FsTm9kZSIsImJvYXJkU2xpY2UiLCJuYW1lIiwicmVkdWNlcnMiLCJpbml0aWFsaXplQm9hcmQiLCJzdGF0ZSIsImFjdGlvbiIsInBheWxvYWQiLCJ1cGRhdGVCb2FyZCIsInVwZGF0ZWRBdCIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsImFkZExpc3QiLCJsaXN0cyIsInB1c2giLCJ1cGRhdGVMaXN0IiwibGlzdElkIiwidXBkYXRlcyIsImxpc3RJbmRleCIsImZpbmRJbmRleCIsImxpc3QiLCJpZCIsImRlbGV0ZUxpc3QiLCJmaWx0ZXIiLCJub2RlcyIsIm5vZGUiLCJyZW9yZGVyTGlzdHMiLCJkcmFnZ2VkSWQiLCJ0YXJnZXRJZCIsImRyYWdnZWRJbmRleCIsInRhcmdldEluZGV4IiwiZHJhZ2dlZExpc3QiLCJzcGxpY2UiLCJmb3JFYWNoIiwiaW5kZXgiLCJvcmRlciIsImFkZFNlY3Rpb24iLCJzZWN0aW9uIiwiZmluZCIsImwiLCJzZWN0aW9ucyIsInVwZGF0ZVNlY3Rpb24iLCJzZWN0aW9uSWQiLCJzZWN0aW9uSW5kZXgiLCJzIiwiZGVsZXRlU2VjdGlvbiIsImxlbmd0aCIsInJlbWFpbmluZ1NlY3Rpb25zIiwiZmlyc3RTZWN0aW9uIiwicmVvcmRlclNlY3Rpb25zIiwiZHJhZ2dlZFNlY3Rpb25JZCIsInRhcmdldFNlY3Rpb25JZCIsImRyYWdnZWRTZWN0aW9uIiwiYWRkTm9kZSIsInVwZGF0ZU5vZGUiLCJub2RlSWQiLCJub2RlSW5kZXgiLCJkZWxldGVOb2RlIiwiZWRnZXMiLCJlZGdlIiwic291cmNlSWQiLCJyZW9yZGVyTm9kZXMiLCJsaXN0Tm9kZXMiLCJkcmFnZ2VkTm9kZSIsIm4iLCJtb3ZlTm9kZSIsInRhcmdldExpc3RJZCIsInRhcmdldExpc3ROb2RlcyIsIm5JbmRleCIsImFkZEVkZ2UiLCJ1cGRhdGVFZGdlIiwiZWRnZUlkIiwiZWRnZUluZGV4IiwiZGVsZXRlRWRnZSIsInNldExpbmtNb2RlIiwic2V0TGlua1NvdXJjZSIsInNldEFjdGl2ZUlkIiwic2V0RHJhZ1R5cGUiLCJzZXREcmFnZ2FibGVOb2RlcyIsInRvZ2dsZU5vZGVEcmFnZ2FibGUiLCJpc0RyYWdnYWJsZSIsImluY2x1ZGVzIiwic2V0Q2F1c2FsUGF0aE1vZGUiLCJzZXRDYXVzYWxQYXRoTm9kZXMiLCJzZXRDYXVzYWxQYXRoRm9jYWxOb2RlIiwiY2xlYXJDYXVzYWxQYXRoIiwiYWN0aW9ucyIsInJlZHVjZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/store/boardSlice.js\n"));

/***/ })

});